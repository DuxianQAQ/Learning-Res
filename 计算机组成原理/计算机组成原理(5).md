# 中央处理器

**考纲内容**

- CPU的功能和基本结构
- 指令执行过程
- 数据通路的功能和基本结构
- 控制器的功能和工作原理
- 异常和中断机制
  异常和终端的基本概念；异常和中断的分类；异常和中断的检测与响应
- 指令流水线
  指令流水线的基本概念；指令流水线的基本实现
  结构冒险、数据冒险和控制冒险的处理；超标量和动态流水线的基本概念
- 多处理器基本概念
  SISD、SIMD、MIMD、向量处理器的基本概念；硬件多线程的基本概念
  多核处理其的基本概念；共享内存多处理器(SMP)的基本概念

数据通路分析、指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题
关于各种寄存器的特点、各种指令执行的周期与特点、控制器的相关概念、流水线的相关概念易出选择题

思考以下问题：

```
1、指令和数据均放在内存中，计算机如何从时间和空间上区分它们石之灵还是数据?
2、什么是指令周期、机器周期、时钟周期?它们之间有什么关系
3、什么是微指令?与指令有什么关系
4、什么是指令流水线?指令流水线相对于传统体系结构的优势是什么
```

## CPU的功能和基本结构

### CPU的功能

中央处理器(CPU)由**`运算器`**和**`控制器`**组成
控制器的功能是**`负责协调并控制计算机各部件执行程序的指令序列`**
运算器的功能是**`对数据进行加工`**

具体功能包括：

1. **指令控制**。完成取指令(取指)、分析指令和执行指令的操作，即程序的顺序控制
2. **操作控制**。产生完成一条指令所需的操作信号，把各种操作信号送到相应的部件，从而控制这些部件按指令的要求正确执行
3. **时间控制**。严格控制各种操作信号的出现时间、持续时间及出现的时间顺序
4. **数据加工**。对数据进行算术和逻辑运算
5. **中断处理**。对运行过程中出现的异常情况和中断请求进行处理

### CPU的基本结构

- **运算器**

主要组成：

```
算术逻辑单元(ALU)
暂存寄存器
累加寄存器(ACC)
通用寄存器(GPRs)
程序状态寄存器(PSW)
位移寄存器
计数器(CT)
等
```

主要功能：

```
根据控制器送来的命令，对数据执行：
运算(加、减、乘、除)
逻辑运算(与、或、非、异或、移位、求补等)
条件测试(用于设置ZF、SF、OF和CF等标志位，作为条件转移的判断条件)
```

- **控制器**

主要组成：

```
程序计数器(PC)
指令寄存器(IR)
指令译码器(ID)
存储器地址寄存器(MAR)
存储器数据寄存器(MDR)
时序电路
位操作信号发生器
等
```

主要功能：

```
执行指令，每条指令的执行是由控制器发出的一组微操作实现的
```

工作原理：

```
根据指令操作码、指令的执行步骤(微命令序列)和条件信号来形成当前计算机各部件要用到的控制信号
计算机整机各硬件系统在这些控制信号的控制下协同运行，产生续期的执行结果
控制器是整个系统的指挥中枢，在控制器的控制下，运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作
```

### CPU的寄存器

CPU中的寄存器按汇编语言(或机器语言)，程序是否可访问，分为两类：

1. **用户可见寄存器**
   可对这类寄存器编程，以**`通过使用这类寄存器减少对主存储器的访问次数`**
   如通用寄存器组(含基址/变址寄存器)、程序状态字寄存器、程序计数器、累加寄存器、移位寄存器
2. **用户不可见寄存器**
   对用户是透明的，不可对这类寄存器编程，它们**`被控制部件使用，以控制CPU的操作`**
   如存储器地址寄存器、存储器数据寄存器、指令寄存器、暂存寄存器

---

**运算器中的寄存器**

1. **通用寄存器组(GRPs)**
   用于**`存放操作数`**(包括源操作数、目的操作数及中间结果)**`和各种地址信息等`**
   如AX、BX、CX、DX、SP等
   在指令中要指定寄存器的编号，才能明确是对哪个寄存器进行访问
2. **累加寄存器(ACC)**
   是一个通用寄存器，用于**`暂时存放ALU运算的结果`**
3. **移位寄存器(SR)**
   不但**`可用来存放操作数`**，而且**`在控制信号的作用下，寄存器中的数据可根据需要向左或向右位移`**
4. **暂存寄存器**
   用于**`暂存从数据总线或通用寄存器送来的操作数`**，以便**`在取出下一个操作数时将其同时送入ALU`**
5. **程序状态字寄存器(PSW)**
   **`保留由算术/逻辑运算指令或测试指令的运行结果而建立的各种状态信息`**
   如溢出标志(OF)、符号标志(SF)、零标志(ZF)、进位标志(CF)等
   每个标志位通常由一位触发器来保存，这些标志位组合在一起称为`程序状态字`

**控制器中的寄存器**

1. **程序计数器(PC)**
   用于**`指出欲执行指令在主存储器中的存放地址`**
   若PC和主存储器均按字节编址，则PC的**`位数等于主存储器地址位数`**
   CPU根据PC的内容从主存储器中取指令，然后送入指令寄存器
   指令通常是顺序执行的，因此**`PC具有自动加1的功能`**(“1”是指一条指令的字节数)
   当**`遇到转移类指令时，PC的新值由指令计算得到`**
2. **指令寄存器(IR)**
   用于**`保存当前正在执行的指令`**，IR的**`位数等于指令字长`**
3. **存储器地址寄存器(MAR)**
   用于**`存放要访问的主存储器单元的地址`**，MAR的**`位数等于主存储器地址线数`**
   **`它反映了最多可寻址的存储单元的个数`**
4. **存储器数据寄存器(MDR)**
   用于**`存放向主存储器写入的信息或从主存储器读出的信息`**，MDR的**`位数等于存储字长`**
   当CPU和主存储器交换信息时，都要用到MAR和MDR

---

注意：

```
1、n位CPU指的是有n位数据总线线数。数据总线的位数与处理器的位数相同，表示CPU一次能处理的数据的位数
2、转移指令时，需要判别转移是否成功，若成功则PC修改为转移指令的目标地址；否则下一条指令的地址仍然为PC自增后的地址
3、程序计数器PC用于指出下一条指令在出存储器中地址。可以用字节地址表示指令地址，此时PC的位数与存储器地址的位数相等，而存储器地址的位数取决于存储器的容量；也可以用字第直表示指令地址，这种情况下指令必须采用按边界对齐的方式存放
此时PC的位数 = 存储器地址的位数 - log2(指令字长的字节数)
即PC的位数取决于存储器的容量和指令字长
4、标志寄存器时专用寄存器，不需要编号，也不能在指令中直接指定编号来访问；标志寄存器中的内容时执行指令的过程中，CPU根据指令执行的结果生成的各种标志信息，用户不能直接修改它
5、指令包括操作码字段和地址码字段，但指令译码器仅对操作码字段进行译码，借以确定指令的操作功能
```

## 指令执行过程

### 指令周期

**`CPU每取出并执行一条指令所需的全部时间`**称为**指令周期**，不同指令的指令周期可能不同。指令周期通常可用若干机器周期来表示，每个指令周期内的机器周期数可以不等

![image-20240717214414951](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240717214414951.png)

对于无条件转移指令`JMP X`，在执行时**`不需要访问主存`**，**`只包含取指阶段`**(包括取指和分析)**`和执行阶段`**，所以其**`指令周期仅包含取指周期和执行周期`**
对于间接寻址的指令，为了**`取操作数，需要先访问一次主存，取出有效地址`**，**`然后访问主存，取出操作数`**，所以**`还需包括间址周期`**。间址周期介于取指周期和执行周期之间
当CPU采用中断方式实现主机和I/O设备的信息交换时，**`CPU在每条指令执行结束前，都要发中断查询信号，若有中断请求，则CPU进入中断响应阶段`**，也称**中断周期**

这样，**`一个完成的指令周期可包括取指、间址、执行和中断4个周期`**：

![image-20240717214901793](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240717214901793.png)

1. 当CPU执行指令时，首先进入**取指周期**
   **`从PC指出的主存单元中取出指令，送至指令寄存器`**，同时**`PC加1以作为下一条指令的地址`**
   当**`遇到转移指令等改变执行顺序的指令时，在PC加1后会重新计算并更新PC值`**
2. 之后进入**执行周期**，**`完成取操作数、执行运算和存操作数的任务`**
3. 执行周期结束后，如果CPU检测到中断请求，则进入**中断周期**，此时需要**`关中断、保存断点、修改PC值位中断服务程序的入口地址并转向中断服务程序`**

### 指令周期的数据流

**`数据流是根据指令要求一次访问的数据序列`**
在指令执行的不同阶段，要求依次访问的数据序列是不同的。对于不同的指令，它们的数据流往往也是不同的

- **取指周期**

取指周期的任务是**`根据PC中的内容从主存中取出指令代码并存放在IR中`**

![image-20240718202902598](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240718202902598.png)

如上所示。PC中存放的是指令的地址，根据此地址从内存单元中取出的是指令，并放在指令寄存器IR中，取指令的同时PC加1

取指周期的数据流向：

1. `PC -> MAR -> 地址总线 -> 存储器`
2. `CU发出读命令 -> 控制总线 -> 存储器`
3. `主存 -> 数据总线 -> MDR -> IR(存放指令)`
4. `CU发出控制信号 -> PC内容加1`

其中，CU表示控制单元

- **间址周期**

间址周期的主要任务是**`取操作数有效地址`**

![image-20240718203350364](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240718203350364.png)

如上所示。将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发出读命令，以获取有效地址并存至MDR

间址周期的数据流向：

1. `Ad(IR)(或MDR) -> MDR -> 地址总线 -> 存储器`
2. `CU发出读命令 -> 控制总线 -> 存储器`
3. `主存 -> 数据总线 -> MDR(存放有效地址)`

其中Ad(IR)表示取出IR中存放的指令字的地址字段

- **执行周期**

执行周期的任务是**`取操作数，并根据IR中的指令字的操作码通过ALU操作产生执行结果`**
不同指令的执行周期不同，因此没有统一的数据流向

- **中断周期**

中断周期的任务是处理中断请求

![image-20240718205351644](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240718205351644.png)

假设程序断点存入堆栈中，并用SP指示栈顶地址，且进栈操作时先修改栈顶指针，后存入数据

中断周期的数据流向：

1. CU控制将SP减1，`SP -> MAR -> 地址总线 -> 存储器`
2. `CU发出写命令 -> 控制总线 -> 存储器`
3. `PC -> MDR -> 数据总线 -> 主存(程序断点存入存储器)`
4. `CU(中断服务程序的入口地址) -> PC`

### 指令执行方案

一个指令周期通常包括几个执行步骤，每个步骤完成指令的一部分功能，几个一次执行的步骤完成这条指令的全部功能
不同的处理器采用不同的方案来安排指令的执行步骤

- **单周期处理器**

单周期处理器**`对所有指令都选用相同的执行时间来完成`**

此时每条指令都在一个时钟周期内完成(CPI = 1)，指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动
因此，**`指令周期取决于执行时间最长的指令的执行时间`**

缺点：`对于那些本来可以在更短时间内完成的指令，仍要使用这个较长的周期来完成`，**`会降低整个系统的运行速度`**

- **多周期处理器**

多周期处理器**`对不同类型的指令选用不同的执行步骤`**

**`指令需要几个周期就为其分配几个周期`**，因此可选用不同个数的时钟周期来完成不同指令的执行过程(即CPI > 1)，**`不再要求所有指令占用相同的执行时间`**

多指令周期方案中**`指令之间仍是串行执行`**

- **流水线处理器**

流水线处理器采用**`指令之间并行执行`**的方案，其追求的目的是**`力争在每个时钟周期完成一条指令的执行过程`**(只在理想情况下才能达到该效果，此时CPI = 1)

这种方案通过**`在每个时钟周期启动一条指令，尽量让多条指令同时运行`**，但**`各自处在不同的执行步骤中`**

---

注意：

```
1、不同长度的指令，其取指操作可能是不同的。如，双字指令、三字指令与单字指令的取指操作是不同的
2、指令周期的第一个周期是取指周期，即从主存中取出指令字的时间
3、存储器间址通过形式地址访存，寄存器间址通过寄存器内容访存
4、单周期CPU执行任何指令的时间不一定都会小于多周期CPU，这取决于单周期CPU和多周期CPU的时钟周期的长短，以及该指令在多周期CPU下所需的时钟周期数。即单周期CPU的时间不一定会小于多周期CPU
5、虽然指令和数据都是以二进制形式存放在存储器，但CPU可以根据指令周期的不同阶段来区分是指令还是数据
通常在取指阶段取出的是指令，在执行阶段取出的是数据
6、CPU只有在确定取出的是指令后，才会将其操作码送去译码，因此不可能依据译码的结果来区分指令和数据
```

## 数据通路的功能和基本结果

### 数据通路的功能

CPU内部结构可视为由**`数据通路`**和**`控制部件`**两大部分组成

**`数据在指令执行过程中所经过的路径，包括路径上的部件`**，称为**数据通路**
`ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等`都是指令执行时数据流经的部件，都属于数据通路的一部分
数据通路**`描述了信息从哪里开始，中间经过哪些部件，最后被传送到哪里`**

**`数据通路由控制部件控制`**，控制部件**`根据每条指令功能的不同生成对数据通路的控制信号`**

### 数据通路的组成

组成数据通路的元件主要分为**`组合逻辑元件`**和**`时序逻辑元件`**两类

- **组合逻辑元件(操作元件)**

**`任何时刻产生的输出仅取决于当前的输入`**

**`组合电路不含存储信号的记忆单元，也不受时钟信号的控制，输出与输入之间无反馈通路，信号是单向传输的`**

数据通路中常用的组合逻辑元件有`加法器、算术逻辑单元(ALU)、译码器、多路选择器、三态门等`

![image-20240719202600874](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240719202600874.png)

图中虚线表示控制信号

译码器可用于操作码或地址码译码，n位输入对应 2^n^ 种不同组合，因此有 2^n^ 个不同输出
多路选择器(MUX)需要控制信号Select来确定选择哪个输入被输出
三态门可视为一种控制开关，由控制信号EN决定信号线的通断，当EN=1时，三态门被打开，输出信号等于输入信号；当EN=0时，输出端呈高阻态(断态)，所连寄存器与总线断开

- **时序逻辑元件(状态元件)**

**`任何时刻的输出不仅与该时刻的输入有关，还与该时刻以前的输入有关`**，因而**`时序电路必然包含存储信号的记忆单元`**。此外，**`时序电路必须在时钟节拍下工作`**

`各类寄存器和存储器`，如`通用寄存器组、程序计数器、状态/移位/暂存/锁存寄存器等`，都属于时序逻辑元件

### 数据通路的基本结构

- **CPU内部单总线方式**

**`将ALU及所有寄存器都连接到一条内部公共总线上`**，称为**单总线结构的数据通路**
这种**`结构比较简单`**，但**`数据传输存在较多的冲突现象，性能较低`**
**`总线在CPU内部`**，注意不要把它与连接 CPU、存储器和外设的系统总线相混淆

![image-20240719212405943](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240719212405943.png)

如上所示，为单总线的数据通路和控制信号

```
GPRs为通用寄存器组
rs、rd分别为所读、写的通用寄存器的编号
Y和Z为暂存器
FR为标志寄存器，用于存放ALU产生的标志信息
带箭头的虚线表示控制信号
字母加 in 表示该部件允许写入，字母加 out 表示该部件允许输出
MDRin表示内部总线上信息写入MDR，MDRout表示MDR的内容送入内部总线
```

**`能输出到总线的部件均通过一个三态门与内部总线相连`**，用于**`控制该部件与内部总线之间数据通路的连接与断开`**

注：`单周期处理器(CPI=1)不能采用单总线方式，因为单总线将所有寄存器都连接到一条公共总线上，一个时钟内只允许一次操作，无法完成一条指令的所有操作`

- **CPU内部多总线方式**

**`CPU内部有两条或更多的总线时`**，构成**双总线结构**或**多总线结构**

将所有寄存器的输入端和输出端都连接到多条公共通路上，采用多总线方式，**`同时在多个总线上传送不同的数据，提高效率`**

- **专用数据通路方式**

根据指令执行过程中的数据和地址的流动方向安排连接电路，**`避免使用共享的总线，性能较高，但硬件量大`**

注：`内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；系统总线是指同一台计算机系统的各部件，如CPU、内存和各类I/0接口间互相连接的总线`

### 数据通路的操作举例

**`总线是一组共享的传输信号线，它不能存储信息，任一时刻也只能有一个部件把信息送到总线上`**

以单总线数据通路为例，介绍一些常见操作的流程及控制信号

1. **通用寄存器之间传送数据**
   在寄存器和总线之间有两个控制信号：Rin和Rout
   当**Rin有效时**，控制**`将总线上的信息存到寄存器R中`**
   当**Rout有效时**，控制**`将寄存器R的内容送至总线`**

   ```
   以程序计数器PC为例，将PC的内容送至MAR
   实现该操作的流程及控制信号为：
   (PC) -> MAR			# PCout 和 MARin 有效，PC内容 -> MAR
   ```

2. **从主存读取数据**
   **`从主存中读取的信息可能是数据或指令`**

   ```
   以CPU从主存中取指令为例，说明数据在单总线数据通路中的传送过程
   实现该操作的流程及控制信号为：
   (PC) -> MAR						# PCout 和 MARin有效，现行指令地址 -> MAR
   MEM(MAR) -> MDR, (PC)+1 -> PC	# MDRin 有效，CU 发出读命令，取出指令后PC+1
   (MDR) -> IR						# MDRout 和 IRin有效，现行指令 -> IR
   ```

   1> 将PC的内容通过内部总线送至MAR，需要一个时钟周期
   2> CU向主存发出读命令，从MAR所指主存单元读取一个字，并送至MDR；同时PC加1为取下一条指令做准备，需要一个时钟周期
   3> 将MDR的内容通过内部总线送至IR，需要一个时钟周期

3. **将数据写入主存**

   ```
   将寄存器R1的内容写入寄存器R2所指的主存单元
   实现该操作的流程及控制信号为：
   (R1) -> MDR			# R1out 和 MDRin 有效
   (R2) -> MAR			# R2out 和 MARin 有效
   MDR -> MEM(MAR)		# MDRout 有效，CU发出写命令
   ```

4. **执行算术或逻辑运算**
   **`在单总线数据通路中，每一时刻总线上只有一个数据有效`**
   由于**`ALU是一个没有存储功能的组合逻辑元件`**，在其**`执行运算时必须保持两个输入端同时有效`**
   因此先将一个操作数经内部总线送入暂存器Y保存，Y的内容在ALU的左输入端始终有效
   再将另一个操作数经内部总线直接送到ALU的右输入端
   此外，**`ALU的输出端也不能直接与总线相连，否则其输出会通过总线反馈到输入端，影响运算结果`**，因此将运算结果暂存在暂存器Z中

   ```
   假设加法指令ADD ACC, RI，实现将ACC的内容和R1的内容相加并写回ACC
   完成该操作的流程及控制信号为：
   (R1) -> Y			# Rlout 和 Yin 有效，操作数 -> Y
   (ACC) + (Y) -> Z	# ACCout 和 ALUin 有效，CU向ALU发出加命令，结果 -> Z
   (Z) -> ACC			# Zout 和 ACCin 有效，结果 -> ACC
   
   以上3步不能同时执行，否则会引起总线冲突，因此该操作需要3个时钟周期
   ```

5. **修改程序计数器的值**
   转移指令通过修改程序计数器PC的值来达到转跳的目的

   ```
   假设转移指令JMP addr，addr为目标转移地址，实现将IR中的地址字段写入PC
   完成该操作的流程及控制信号为：
   Ad(IR) -> PC		# IRout 和 PCin 有效
   ```


数据通路结构直接影响CPU内各种信息的传送路径，数据通路不同，指令执行过程的微操作序列的安排也不同，它关系着微操作信号形成部件的设计

---

提醒：

```
1、在单总线的CPU中，ALU只能有一个输入端可以与总线相连，另一输入端通过暂存器与总线相连
2、单总线数据通路将所有寄存器的输入输出端都连接在一条公共通路上，一个时钟内只允许一次操作，无法完成指令的所有操作
3、控制信号是CU根据指令操作码发出的信号，对于单周期处理器来说，每条指令的执行只有一个时钟周期，而在一个时钟周期内控制信号并不会发生变化；若是多周期处理器，则指令的执行需要多个时钟周期，在每个时钟控制周期会发出不同信号
```

## 控制器的功能和工作原理

### 控制器的结构和功能

计算机硬件系统的五大功能部件及其连接关系：

![image-20240722203429773](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240722203429773.png)

它们**`通过数据总线、地址总线和控制总线连接在一起`**，点画线框内的是控制器部件

1. **`运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据`**
2. **`输入设备和输出设备通过接口电路与总线相连接`**
3. **`内存储器、输入设备和输出设备从地址总线接收地址信息`**，**`从控制总线得到控制信号通过数据总线与其他部件传送数据`**
4. **`控制器部件从数据总线接收指令信息`**，**`从运算器部件接收指令转移地址`**，**`送出指令地址到地址总线`**，还要**`向系统中的部件提供它们运行所需要的控制信号`**

**控制器**是**`计算机系统的指挥中心`**

主要功能有：

1. **`从主存中取出一条指令`**，并**`指出下一条指令在主存中的位置`**
2. **`对指令进行译码或测试`**，**`产生相应的操作控制信号`**，以便启动规定的动作
3. **`指挥并控制CPU、主存、输入设备和输出设备之间的数据流动方向`**

**`根据控制器产生微操作控制信号的方式的不同`**，控制器可分为**`硬布线控制器`**和**`微程序控制器`**
两类控制器中的**`PC和IR是相同的`**，但确定和表示指令执行步骤的办法及给出控制各部件运行所需要的控制信号的方案是不同的

### 硬布线控制器

硬布线控制器**`由复杂的组合逻辑门电路和触发器构成`**，也称`组合逻辑控制器`
其原理是**`根据指令的要求、当前的时序及内外部的状态，按时间的顺序发送一系列微操作控制信号`**

**`指令的操作码是决定控制单元(CU)发出不同控制信号的关键`**
为了简化CU的逻辑，将存放在IR的 n 位操作码经过译码电路产生 2^n^ 个输出，**`每种操作码对应一个输出送至CU`**

![image-20240722205551583](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240722205551583.png)

控制单元(CU)的输入信号来源如下：

1. **`经指令译码器译码产生的指令信息`**。现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，它与时钟配合产生不同的控制信号
2. **`时序系统产生的机器周期信号和节拍信号`**。为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制
3. **`来自执行单元的反馈信息即标志`**。控制单元有时需依赖CPU当前所处的状态产生控制信号，如BAN指令，控制单元要根据上条指令的结果是否为负来产生不同的控制信号

节拍发生器产生各机器周期中的节拍信号，使不同的微操作命令 C~i~ (控制信号)按时间的先后发出
个别指令的操作不仅受操作码控制，而且受到状态标志控制，因此：
CU的输入来自操作码译码电路ID、节拍发生器及状态标志；输出到CPU内部或外部控制总线上

硬布线控制的功能由逻辑门组合实现，其**`速度主要取决于电路延迟`**，因此**`CPU往往采用硬布线逻辑实现`**；**`RISC一般都选用硬布线控制器`**

硬布线控制器的控制信号先用逻辑式列出，经化简后用电路来实现，因此显得零乱复杂，**`当需要修改或增加指令时就必须重新设计电路`**，非常麻烦。而且指令系统功能越全，微操作命令就越多，电路也就越庞杂，调试就更困难

### 微程序控制器

微程序控制器**`采用存储逻辑实现`**，也就是将微操作信号代码化，**`使每条机器指令转化成为一段微程序并存入一个专门的存储器(控制存储器)中`**，**`微作控制信号由微指令产生`**

---

- **微程序控制的基本概念**

微程序的设计思想就是**`将每条机器指令编写成一个微程序`**，**`每个微程序包含若干微指令`**，**`每条微指令对应一个或几个微操作命令`**
因此，**`执行一条指令的过程就是执行一个微程序的过程`**，这些**`微程序存储在一个控制存储器中`**

**1> 微命令与微操作**

在微程序控制的计算机中，**`控制部件向执行部件发出的各种控制命令`**称为**微命令**，它是**`构成控制序列的最小单位`**
**`执行部件收到微命令后所进行的操作`**称为**微操作**，**`微命令和微操作是一一对应的`**

**`微命令有相客性和互斥性之分`**
相容性微命令是指那些可以同时出现、共同完成某一些微操作的微命令
互斥性微命令是指在机器中不允许同时出现的微命令

注：`硬布线控制器中也有微命令与微操作的概念，并非微程序控制器的专有概念`

**2> 微指令与微周期**

微指令是若干微命令的集合，一条微指令通常至少包含两大部分信息：

1.  **操作控制字段**，也称`微操作码字段`
   **`用于产生某一步操作所需的各种操作控制信号`**
2. **顺序控制字段**，也称**`微地址码字段`**
   **`用于控制产生下一条要执行的微指令地址`**

**微周期**是指**`从控制存储器中取出并执行一条微指令所需的全部时间`**，通常为一个时钟周期

**3> 主存储器与控制存储器**

**主存储器**用于**`存放程序和数据`**，**`在CPU外部，用RAM实现`**
**控制存储器**(CM)用于**`存放微程序`**，**`在CPU内部，用ROM实现`**

**`存放微指令的控制存储器的单元地址`**称为**微地址**

**4> 程序与微程序**

微程序和程序是两个不同的概念
**程序**是`指令的有序集合`，**`用于完成特定的功能`**
**微程序**是`微指令的有序集合`，**`用于描述机器指令`**，一条指令的功能由一段微程序来实现

**`微程序实际上是机器指令的实时解释器`**，是由计算机设计者**`事先编制好并存放在控制存储器中`**的。对于程序员来说，系统中微程序的结构和功能是透明的
**`程序最终由机器指令组成`**，并且由软件设计人员**`事先编制好并存放在主存储器或者辅助存储器中`**

注意区分以下寄存器：

1. **地址寄存器(MAR)**。用于**`存放主存的读/写地址`**
   **微指令地址寄存器(μPC或CMAR)**。用于**`存放待执行的微指令在控制存储器中的微地址`**
2. **指令寄存器(IR)**。用于**`存放从主存中读出的指令`**
   **微指令寄存器(μIR或CMDR)**。用于**`存放从控制存储器中读出的微指令`**

---

- **微程序控制器的组成和工作过程**

**1> 微程序控制器的基本组成**

![image-20240722212553313](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240722212553313.png)

上图所示为一个微程序控制器的基本结构，其主要部件包括：

1. **起始和转移地址形成部件**(或简称微地址形成部件)。用于**`产生初始和后继微地址，以保证微指令的连续执行`**
2. **微指令地址寄存器**。**`接收微地址形成部件送来的微地址，为读取微指令做准备`**
3. **控制存储器**。它是**`微程序控制器的核心部件`**，用于**`存放各指令对应的微程序`**
4. **微指令寄存器**。其**`位数等于微指令字长`**

**2> 微程序控制器的工作过程**

实际上就是**`在微程序控制器的控制下计算机执行机器指令的过程`**，这个过程可描述为：

1. **执行取指令公共操作**
   在机器开始运行时，**`自动将取指微程序的入口地址送入μPC`**，并**`从CM中读出相应的微指令并送入μIR`**
   取指微程序的入口地址一般为CM的0号单元
   **`取指微程序执行完成后，从主存中取出的机器指令就已存入指令寄存器中`**
2. **`由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入μPC`**
3. **`从CM中逐条取出对应的微指令并执行`**
4. 执行完对应于一条机器指令的一个微程序后，又**`回到取指微程序的入口地址，继续第1步`**，以完成取下一条机器指令的公共操作

以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕

**3> 微程序和机器指令**

通常，一条机器指令对应一个微程序
由于任何机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器
此外，也可编写出对应间址周期的微程序和中断周期的微程序
这样，**`控制存储器中的微程序个数`**应为**`机器指令数再加上对应取指、间址和中断周期等公共的微程序数`**

---

- **微指令的编码方式**

微指令的编码方式也称`微指令的控制方式`，是指**`如何对微指令的控制字段进行编码，以形成控制信号`**
编码的目标是**`在保证速度的情况下，尽量缩短微指令字长`**

**1> 直接编码(直接控制)方式**

![image-20240722214132534](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240722214132534.png)

直接编码法**`无须进行译码`**，微指令的**`操作控制字段中每一位都代表一个微命令`**
设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1或0即可
**`每个微命令对应并控制数据通路中的一个微操作`**

优点：**`简单、直观，执行速度快，操作并行性好`**
缺点：**`微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控制存储器容量极大`**

**2> 字段直接编码方式**

![image-20240722214145956](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240722214145956.png)





**`将微指令的操作控制字段分成若干小字段`**
把互斥性微命令放在同一字段中；把相容性微命令放在不同字段中
**`每个字段独立编码`**，**`每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关`**

优点：**`可以缩短微指令字长`**
缺点：因为**`要通过译码电路后再发出微命令`**，因此**`比直接编码方式慢`**

微命令字段分段的原则：

1. **`互斥性微命令分在同一段内，相容性微命令分在不同段内`**
2. **`每个小段中包含的信息位不能太多`**，否则将增加译码电路的复杂性和译码时间
3. 一般**`每个小段还要留出一个状态，表示本字段不发出任何微命令`**
   因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用`000`表示不操作

**3> 字段间接编码方式**

**`一个字段的某些微命令需由另一个字段中的某些微命令来解释`**，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，也称`隐式编码`
这种方式**`可进一步缩短微指令字长`**，但因**`削弱了微指令的并行控制能力`**，因此通常作为字段直接编码方式的一种辅助手段

---

- **微指令的地址形成方式**

后继微地址的形成主要有以下几个基本类型：

1. **`由微指令的后继地址字段(也称下地址字段)指出`**。在微指令格式中设置一个后继地址字段，**`由微指令的后继地址字段直接指出后继微指令的地址`**，这种方式也称`断定方式`
2. **`根据机器指令的操作码形成`**。当机器指令取自指令寄存器后，**`微指令的地址由操作码经微地址形成部件形成`**，该部件**`输出的是对应机器指令微程序的首地址`**
3. **`增量计数器法`**，即**`(μPC) + 1 -> μPC`**，**`适用于后继微指令地址是连续的情况`**
4. **`根据各种标志决定下一条微指令分支转移的地址`**
5. **`由硬件直接产生微程序入口地址`**。电源加电后，第一条微指令的地址可由专门的硬件电路产生，并送至μPC，这个地址即为取指周期微程序的入口地址

---

- **微指令的格式**

微指令格式与微指令的编码方式有关，通常分为**`水平型微指令和垂直型微指令`**两种

**1> 水平型微指令**

从编码方式看，**`直接编码、字段直接编码和字段间接编码都属于水平型微指令`**

![image-20240722215632592](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240722215632592.png)

指令字中的一位对应一个控制信号，有输出时为1，否则为0
**`一条水平型微指令定义并执行多个并行操作的微命令`**

优点：**`微程序短，并行能力强，执行速度快`**
缺点：**`微指令长，编写微程序较麻烦`**

**2> 垂直型微指令**

采用类似机器指令操作码的方式，**`在微指令字中设置微操作码字段`**

![image-20240722215830199](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240722215830199.png)

**`一条垂直型微指令通常只能定义并执行一种微指令`**

优点：**`微指令短、简单、规整，便于编写微程序`**
缺点：**`微程序长，执行速度慢，效率低`**

水平型微指令和垂直型微指令的比较：

```
1、水平型微指令并行操作能力强、效率高、灵活性强；垂直型微指令则较差
2、水平型微指令执行一条指令的时间短；垂直型微指令执行的时间长
3、用水平型微指令编写的微程序，微指令字较长但微程序短；垂直型微指令正好相反
4、水平型微指令难以掌握；而垂直型微指令与机器指令比较相似，相对容易掌握
```

---

- **硬布线和微程序控制器的特点**

**1> 硬布线控制器的特点**

优点：由于**`控制器的速度取决于电路延迟，所以速度快`**
缺点：由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标，一旦设计完成，就**`不可能通过其他额外修改添加新功能`**

**2> 微程序控制器的特点**

优点：**`相比组合逻辑控制器具有规整性、灵活性和可维护性`**
缺点：**`由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中取一次，影响速度`**

![image-20240722220634235](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240722220634235.png)

---

提醒：

```
1、微程序控制器的速度比硬布线控制器慢，主要是因为增加了从控制器读取微指令的时间
2、微程序控制存储器用来存放微程序，是微程序控制器的核心部件，属于CPU的不一部分
3、微程序只需按照节拍的安排，顺序执行微指令，因此微程序控制器的时序系统比较简单
4、控制部件向执行部件发出的控制信号称为微命令；微命令执行的操作称为微操作；微指令是若干微命令的集合；若干微指令的有序集合称为微程序
5、在同一CPU周期中，可以同时出现的微命令叫相容性微命令，不允许同时出现的微命令叫互斥性微命令
6、一条指令对应一个微程序，一个微程序的周期对应一个指令周期
7、主存储器(MM)在CPU外，用于存储指令和数据，由RAM和ROM实现(主要是RAM)
控制存储器(CS)用来存放构成指令系统的所有微指令，是一种只读型存储器，机器运行时只读不写，在CPU的控制器内。控制存储器按照微指令的地址访问
```

## 异常和中断机制

### 异常和中断的基本概念

**`由CPU内部产生的意外事件`**被称为**异常**，也称`内中断`
**`由来自CPU外部的设备向CPU发出的中断请求`**被称为**中断**，通常用于信息的输入和输出，也称`外中断`

**异常**是**`CPU执行一条指令时，由CPU在其内部检测到的、与正在执行的指令相关的同步事件`**
**中断**是一种典型的**`由外部设备触发的、与当前正在执行的指令无关的异步事件`**

异常和中断处理过程的描述如下：

```
若CPU在执行用户程序的第 i 条指令时检测到一个异常事件，或者执行第 i 条指令后发现一个中断请求信号，则CPU打断当前程序，然后转去执行相应的异常或中断处理程序
若异常或中断处理程序能够解决相应的问题，则在异常或中断处理程序的最后，CPU通过执行异常或中断返回指令，回到被打断的用户程序的第 i 条指令或第 i+1 条指令继续执行
若异常或中断处理程序发现是不可恢复的致命错误，则终止用户程序
```

通常情况下，**`对异常和中断的具体处理过程由操作系统(和驱动程序)完成`**
异常和中断的处理过程基本是相同的，两者有时统称为`中断`

### 异常和中断的分类

- **异常的分类**

异常是**`由CPU内部产生的意外事件`**，分为**`硬故障中断和程序性异常`**

**硬故障中断**是**`由硬连线出现异常引起`**的，如`存储器校验错、总线错误等`
**程序性异常**也称`软件中断`，指**`在CPU内部因执行指令而引起的异常事件`**，如`整除0、溢出、断点、单步跟踪、非法指令、栈溢出、地址越界、缺页等`

`按异常发生原因和返回方式的不同`，可分为**`故障、自陷和终止`**

1. **故障(Fault)**
   指**`在引起故障的指令启动后、执行结束前被检测到的异常事件`**
   如，指令译码时，出现“非法操作码”；取数据时，发生“缺段”或“缺页”；执行整数除法指令时，发现“除数为 0”等
   对于“缺段”、“缺页”等异常事件，经处理后，可将所需的段或页面从磁盘调入主存，**`回到发生故障的指令继续执行，断点为当前发生故障的指令`**
   对于“非法操作码”、“除数为0”等，因为无法通过异常处理程序恢复故障，因此**`不能回到原断点执行，必须终止进程的执行`**

2. **自陷(Trap)**
   自陷也称`陷阱`或`陷入`，它是**`预先安排的一种“异常”事件`**，就像预先设定的“陷阱”一样
   事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个“陷阱”
   当执行到被设置了“陷阱”的指令时，CPU在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理，然后**`返回到自陷指令的下一条指令执行`**
   当自陷指令是**`转移指令`**时，并不是返回到下一条指令执行，而是**`返回到转移目标指令执行`**
   在x86机器中，用于**`程序调试“断点设置”和单步跟踪`**的功能就是通过陷阱机制实现的
   此外，系统调用指令、条件自陷指令(如MIPS中的`teq、teqi、tne、tnei`等)等都属于陷阱指令，执行到这些指令时，无条件或有条件地自动调出操作系统内核程序进行执行

   **`故障异常和自陷异常属于程序性异常(软件中断)`**

3. **终止(Abont)**
   如果在执行指令的过程中**`发生了使计算机无法继续执行的硬件故障`**，如`控制器出错、存储器校验错、总线错误等`，那么**`程序将无法继续执行，只能终止`**，此时，**`调出异常服务程序来重启系统`**
   这种异常与故障和自陷不同，不是由特定指令产生的，而是**`随机发生的`**

   **`终止异常和外中断属于硬件中断`**

- **中断的分类**

中断是指**`来自CPU外部、与CPU执行指令无关的事件引起的中断`**，包括`IO设备发出的IO中断(如键盘输入、打印机缺纸等)`，或`发生某种特殊事件(如用户按 Esc 键、定时器计数时间到)等`

外部IO设备**`通过特定的中断请求信号线向CPU提出中断请求`**，**`CPU每执行完一条指令就检查中断请求信号线`**，如果检测到中断请求，则进入中断响应周期

中断可分为**`可屏蔽中断和不可屏蔽中断`**

1. **可屏蔽中断**
   指**`通过可屏蔽中断请求线INTR向CPU发出的中断请求`**
   CPU可以通过在中断控制器中设置相应的屏蔽字来屏蔽它或不屏蔽它，被屏蔽的中断请求将不被送到CPU
2. **不可屏蔽中断**
   指**`通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求`**，通常是非常紧急的硬件故障，如电源掉电等
   这类中断请求信号不可被屏蔽，以让CPU快速处理这类紧急事件

中断和异常在本质上是一样的，但它们之间有以下两个重要的不同点：

```
1、“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成
2、异常的检测由CPU自身完成，不必通过外部的某个信号通知CPU。对于中断，CPU必须通过中断请求线获取中断源的信息，才能知道哪个设备发生了何种中断
```

注：`所有的异常和中断时间都是由硬件检测发现的`

此外，`根据识别中断服务程序地址的方式`，可分为**`向量中断和非向量中断`**；`根据中断处理过程是否允许被打断`，还可分为**`单重中断和多重中断`**

- **异常和中断响应过程**

CPU执行指令时，**`如果发生了异常或中断请求，必须进行相应的处理`**
从CPU检测到异常或中断事件，到调出相应的处理程序，整个过程称为**异常和中断响应**

CPU对异常和中断响应的过程可分为**`关中断`**、`**保存断点和程序状态`**、**`识别异常和中断并转到相应的处理程序`**

1. **关中断**
   在保存断点和程序状态期间，不能被新的中断打断，因此要禁止响应新的中断，即关中断
   通常通过设置**`“中断允许”(IF)触发器`**来实现，若**`IF置为1`**，则为**`开中断`**，表示**`允许响应中断`**；若**`IF置为0`**，则**`表示关中断`**，表示**`不允许响应中断`**
2. **保存断点和程序状态**
   为了能在异常和中断处理后正确返回到被中断的程序继续执行，**`必须将程序的断点(返回地址)送到栈或特定寄存器中`**
   通常保存在栈中，这是为了支持异常或中断的嵌套
   异常和中断处理后可能还要回到被中断的程序继续执行，被中断时的程序状态字寄存器PSW的内容也需要保存在栈或特定寄存器中，在异常和中断返回时恢复到PSW中
3. **识别异常和中断并转到相应的处理程序**
   异常和中断源的识别有**`软件识别和硬件识别`**两种方式
   异常和中断源的识别方式不同，**`异常大多采用软件识别方式`**，而**`中断可以采用软件识别方式或硬件识别方式`**
   **软件识别方式**是指**`CPU设置一个异常状态寄存器，用于记录异常原因`**。**`操作系统使用一个统一的异常或中断查询程序`**，**`按优先级顺序查询异常状态寄存器，以检测异常和中断类型`**，**`先查询到的先被处理`**，然后**`转到内核中相应的处理程序`**
   **硬件识别方式**也称`向量中断`，**`异常或中断处理程序的首地址`**称为中断向量，**`所有中断向量都存放在中断向量表中`**。每个异常或中断都被指定一个中断类型号。在中断向量表中，**`类型号和中断向量一一对应`**，因而可以**`根据类型号快速找到对应的处理程序`**

**`整个响应过程是不可被打断的`**。中断响应过程结束后，CPU就从PC中取出对应中断服务程序的第一条指令开始执行，直至中断返回，这部分任务是由CPU 通过执行中断服务程序完成的。**`整个中断处理过程是由软/硬件协同实现的`**

---

提醒：

```
1、在硬件层，CPU中由检测异常和中断事件并将控制转移到操作系统内核执行的机制
在操作系统层，内核能通过进程的上下文切换将一个进程的执行转移到另一个进程的执行，它们都会产生异常控制流
响应异常/中断请求后，CPU执行的时异常中断/服务程序，是操作系统的内核程序
进程上下文切换由操作系统的内核程序实现
而异常/中断的响应则由硬件实现
2、自陷是一种内部异常
3、系统调用属于自陷，断点为自陷指令的下一条指令地址
4、DMA控制器需要向CPU发送中断请求，属于外中断，外中断的断点为下一条指令地址。同样打印机缺纸也属于外部中断
5、页缺失属于内部异常中的故障，断点为发生故障的指令地址，执行完缺页异常处理程序之后必须返回发生故障的指令重新执行
```

## 指令流水线

前面介绍的指令都是在单周期处理机中采用串行方法执行的，**`同一时刻CPU中只有一条指令在执行`**，因此**`各功能部件的使用率不高`**
现代计算机普遍采用**指令流水线技术**，**`同一时刻有多条指令在CPU的不同功能部件中并发执行`**，**`大大提高了功能部件的并行性和程序的执行效率`**

### 指令流水线的基本概念

可从两方面提高处理机的并行性：

1. **时间上的并行技术**
   将**`一个任务分解为几个不同的子阶段`**，每个子阶段**`在不同的功能部件上并行执行`**，以便**`在同一时刻能够同时执行多个任务`**，进而提
   升系统性能，这种方法被称为**流水线技术**
2. **空间上的并行技术**
   **`在一个处理机内设置多个执行相同任务的功能部件`**，并**`让这些功能部件并行工作`**，这样的处理机被称**超标量处理机**

一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成
如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线

假设一条指令的执行过程分为如下5个阶段(也称功能段或流水段)：

1. **取指(IF)**：**`从指令存储器或Cache中取指令`**
2. **译码/读寄存器(ID)**：**`操作控制器对指令进行译码，同时从寄存器堆中取操作数`**
3. **执行/计算地址(EX)**：**`执行运算操作或计算地址`**
4. **访存(MEM)**：**`对存储器进行读/写操作`**
5. **写回(WB)**：**`将指令执行结果写回寄存器堆`**

把`k+1`条指令的取指阶段提前到第`k`条指令的译码阶段，从而将第`k+1`条指令的译码阶段与第`k`条指令的执行阶段同时进行：

![image-20240724212122661](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240724212122661.png)

**理想情况**下，**`每个时钟周期都有一条指令进入流水线，每个时钟周期都有一条指令完成`**，**`每条指令的时钟周期数(即CPI)都为1`**

为了利于实现指令流水线，指令集应具有如下特征：

1. **`指令长度应尽量一致`**，**`有利于简化取指令和指令译码操作`**。否则，取指令所花的时间长短不一，使得取指部件极其复杂，并且也不利于指令译码
2. **`指令格式应尽量规整，尽量保证源寄存器的位置相同`**，**`有利于在指令未知时就可取寄存器操作数`**，否则须译码后才能确定指令中各寄存器编号的位置
3. **`采用LOAD/STORE型指令，其他指令都不能访问存储器`**，这样`可把LOAD/STORE指令的地址计算和运算指令的执行步骤规整在同一个周期中`，**`有利于减少操作步骤`**
4. 数据和指令在存储器中**`按边界对齐`**存放。这样，**`有利于减少访存次数`**，`使所需数据在一个流水段内就能从存储器中得到`

### 流水线的基本实现

- **流水线设计的原则**

在单周期实现中，虽然不是所有指令都必须经历完整的5个阶段，但**`只能以执行速度最慢的指令作为设计其时钟周期的依据`**，**`单周期CPU的时钟频率取决于数据通路中的最长路径`**

流水线设计的原则：

```
1、指令流水段个数以最复杂指令所用的功能段个数为准
2、流水段的长度以最复杂的操作所花的时间为准

假设某条指令的5个阶段所花的时间分别如下：
取指:200ps
译码:100ps
执行:150ps
访存:200ps
写回:100ps
该指令的总执行时间为750ps
按照流水线设计原则，每个流水段的长度为200ps，所以每条指令的执行时间为1000ps(1ns)，反而比串行执行时增加了250ps
```

**`流水线方式并不能缩短单条指令的执行时间，但对于整个程序来说，执行效率得到了大幅提高`**

- **流水线的逻辑结构**

每个流水段后面都要增加一个**流水段寄存器**，**`用于锁存本段处理完的所有数据`**，`以保证本段的执行结果能在下个时钟周期给下一流水段使用`

![image-20240724213315833](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240724213315833.png)

**`各种寄存器和数据存储器均采用统一时钟CLK进行同步`**，每来一个时钟，**`各段处理完的数据都将锁存到段尾的流水段寄存器中，作为后段的输入`**。同时，**`当前段也会收到前段通过流水段寄存器传递过来的数据`**

一条指令会依次进入IF、ID、EX、MEM、WB五个功能段进行处理
第一条指令进入WB段后，各流水段都包含一条不同的指令，**`流水线中将同时存在5条不同的指令并行执行`**

注：`若没有明确说明，则可以不用考虑流水寄存器的时延`

- **流水线的时空图表示**

通常用时空图来直观地描述流水线的执行情况

![image-20240724213531601](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240724213531601.png)

在时空图中，横坐标表示时间，它被分割成长度相等的时间段T；纵坐标为空间，表示当前指令所处的功能部件

在上图中，第一条指令在时刻0进入流水线，在时刻5T流出流水线；第二条指令上在时刻T进入流水线，在时刻6T流出流水线；以此类推，每隔一个时间T就有一条指令进入流水线。从时刻5T开始每隔一个时间T就有一条指令流出流水线
在时刻10T时，流水线上有6条指令流出。若采用串行方式执行，在时刻10T时，只能执行2条指令，可见**`使用流水线方式成倍地提高了计算机的速度`**

**`只有大量连续任务不断输入流水线，才能充分发挥流水线的性能`**，而指令的执行正好是连续不断的，非常适合采用流水线技术
对于其他部件级流水线，如浮点运算流水线，同样也仅适合于提升浮点运算密集型应用的性能，**`对于单个运算是无法提升性能的`**

### 流水线的冒险与处理

在指令流水线中，可能会遇到一些情况使得后续指令无法正确执行而引起流水线阻塞，这种现象称为**流水线冒险**
根据导致冒险的原因不同分为**`结构冒险、数据冒险和控制冒险`**3种

不同类型指令在各流水段的操作是不同的

![image-20240724213924999](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240724213924999.png)

- **结构冒险**

**`由不同指令在同一时刻争用同一功能部件而形成的冲突`**，也称`资源冲突`，即**`由硬件资源竞争造成的冲突`**

---

如：

指令和数据通常都存放在同一存储器中，在第4个时钟周期，第`i`条LOAD指令进入MEM段时，第`i+3`条指令的IF段也要访存取指令，此时会发生访存冲突，为此可在前一条指令访存时，暂停(一个时钟周期)取后一条指令的操作

![image-20240724214336313](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240724214336313.png)

当然，如果第`i`条指令不是LOAD指令，在MEM段不访存，也就不会发生访存冲突

---

解决结构冲突有以下两种办法：

1. **`前一指令访存时，使后一条相关指令(及其后续指令)暂停一个时钟周期`**
2. **`设置多个独立的部件`**
   如，对于寄存器访问冲突，可将寄存器的读口和写口独立开来；对于访存冲突，单独设置数据存储器和指令存储器
   在现代Cache机制中，L1级Cache通常采用数据Cache和指令Cache分离的方式，从而也就避免了资源冲突的发生

- **数据冒险**

数据冒险也称`数据相关`
引起数据冒险的原因是，**`后面指令用到前面指令的结果时，前面指令的结果还没有产生`**

在以非乱序执行的流水线中，所有数据冒险都是由于前面指令写结果之前，后面指令就需要读取而造成的，这种数据冒险称为**写后读**(RAW)**冲突**

注：`在按序执行的流水线中，只可能出现RAW冲突`

---

如：

考虑下列两条指令：

```
I1	add Rl, R2, R3			# (R2) + (R3) -> R1
I2	sub R4, R1, R5			# (R1) - (R5) -> R4
```

在写后读(RAW)冲突中，指令`I2`的源操作数是指令`I1`的目的操作数
正常的读/写顺序是`由指令 I1 先写入 R1 `，`再由指令 I2 来读 R1`
在非流水线中，这种先写后读的顺序是自然维持的
在流水线中，由于重叠操作，读/写的先后顺序关系发生了变化

![image-20240724215159000](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240724215159000.png)

---

可以采用以下几种办法解决RAW数据冲突：

1. **延迟执行相关指令**
   **`把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行`**，可分为软件插入空操作`nop指令`和`硬件阻塞(stall)`两种方法

   上例所示，在第5个时钟周期，add指令才将运算结果写入R1，但后继sub指令在第3个时钟周期就要从R1中读数，使先写后读的顺序改变为先读后写，发生了先写后读(RAW)的数据冲突。如果不采取措施，就会导致结果出错

   为此，可以暂停sub指令3个时钟周期，直至前面add指令的结果生成

   ![image-20240725200830465](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240725200830465.png)

   对于`I1`和`I2`的数据相关问题，还可以**`通过将寄存器的写口和读口分别控制在前、后半个时钟周期内操作`**，使前半周期写入R1的值在后半周期马上被读出，在一个周期内读/写寄存器不会产生冲突，这样`I1`的WB段和`I2`的ID段就可重叠执行，从而只需延迟2个时钟周期

2. **采用转发(旁路)技术**
   **`设置相关转发通路`**，不等前一条指令把计算结果写回寄存器，下一条指令也不再从寄存器读，而**`将数据通路中生成的中间数据直接转发到ALU的输入端`**

   ![image-20240725201656223](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240725201656223.png)

   如上所示，指令`I1`在EX段结束时己得到R1的新值，被存放到EX/MEM流水段寄存器中，因此可以直接从该流水段寄存器中取出数据返送到ALU的输入端，这样，在指令`I2`执行时ALU中用的就是R1的新值

   增加转发通路后，相邻两条运算类指令之间、相隔一条的两个运算类指令之间的数据相关带来的数据冒险问题就都能解决了

3. **load - use数据冒险的处理**
   如果**`load指令与其后紧邻的运算类指令存在数据相关问题，则无法通过转发技术来解决`**，通常把这种情况称为`load - use`数据冒险

   ```
   对于下面两条指令：
   I2	load r2, l2(r1)			# M[(r1)+l2] -> (r2)
   I3	add r4, r3, r2			# (r3) + (r2) -> (r4)
   ```

   load指令只有在MEM段结束时才能得到主存中的结果，然后送MEM/WB流水段寄存器，在WB段的前半周期才能存入R2的新值，但随后的add指令在EX阶段就要取R2的值，因此，得到的是旧值

   对于`load - use`数据冒险，最简单的做法是由编译器在add指令之前插入一条nop指令，这样在add指令的EX段就可以从MEM/WB流水段寄存器中取出load指令的最新结果，如下所示

   ![image-20240725202821796](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240725202821796.png)

   当然，最好的办法是**`在程序编译时进行优化，通过调整指令顺序以避免出现load - use现象`**

- **控制冒险**

**`指令通常是顺序执行的，但当遇到改变指令执行顺序的情况`**，例如执行转移或返回指令、发生中断或异常时，**`会改变PC值，从而造成断流`**，也称`控制冲突`

对于由转移指令引起的冲突，最简单的处理方法就是**`推迟后续指令的执行`**。通常把**`因流水线阻塞带来的延迟时钟周期数`**称为`延迟损失时间片C`

---

在下列指令中，假设R2存放常数N，R1的初值为1，`bne`指令在EX段通过计算设置条件码，并在MEM段确定是否将PC值更新为转移目的地址，因此仅当`bne`指令执行到第5个时钟结束时才能将转移目标地址送PC

```
I1	loop:add R1, R1, 1			# (R1) + 1 -> R1
I2	bne R1, R2, loop			# #if(R1) != (R2) goto loop
```

为此，在数据通路检测到分支指令后，可以在分支指令后插入C(此处C=3)条`nop`指令

![image-20240725204051035](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240725204051035.png)

---

有以下几种办法解决控制冲突：

1. 对于**`由转移指令引起的冲突`**可**`采用和解决数据冲突相同的软件插入nop指令和硬件阻塞(stall)的方法`**
   如：延迟损失多少时间片，就插入多少条nop指令
2. **`对转移指令进行分支预测，尽早生成转移目标地址`**
   分支预测分为`简单(静态)预测`和`动态预测`
   若**`静态预测的条件总是不满足`**，则**`按序继续执行分支指令的后续指令`**
   动态预测**`根据程序转移的历史情况，进行动态预测调整，有较高的预测准确率`**

注：`Cache缺失的处理过程也会引起流水线阻塞`

### 流水线的性能指标

- **流水线的吞吐率**

**流水线的吞吐率(TP)**是指**`在单位时间内流水线所完成的任务数量，或输出结果的数量`**
$$
TP = \frac {n}{Tk}
$$
n是任务数；T~k~是处理完n个任务所用的总时间

设k为流水段的段数；Δt为时钟周期
在输入流水线中的任务连续的理想情况下，一条k段流水线能在`k + n-1`个时钟周期内完成个n任务。此时流水线吞吐率为：
$$
TP = \frac {n}{(k + n-1)Δt}
$$
连续输入的任务数n趋近于无穷时，得到最大吞吐率为**TP~max~ = 1 / Δt**

- **流水线的加速比**

**流水线的加速比(S)**是指**`完成同样一批任务，不使用流水线与使用流水线所用的时间之比`**
$$
S = \frac{T0}{Tk}
$$
T~0~表示不适用流水线的总时间；T~k~表示使用流水线的总时间

一条k段流水线完成n个任务所需的时间为：**T~k~ = (k + n-1)Δt**
顺序执行n个任务时，所需的总时间为**T~0~ = knΔt**

则流水线的加速比为：
$$
S = \frac{knΔt}{(k + n-1)Δt} = \frac{kn}{k + n-1}
$$
连续输入的任务数n趋近于无穷时，得到最大加速比为**S~max~ = k**

### 高级流水线技术

有两种增加指令级并行的策略：

1. **多发射技术**，它通过**`采用多个内部功能部件，使流水线功能段能同时处理多条指令`**，处理机一次可以发射多条指令进入流水线执行
2. **超流水线技术**，它通过**`增加流水线级数来使更多的指令同时在流水线中重叠执行`**

- **超标量流水线技术**

也称`动态多发射技术`，**`每个时钟周期内可并发多条独立指令`**，**`以并行操作方式将两条或多条指令编译并执行`**，为此**`需配置多个功能部件`**

![image-20240725211853565](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240725211853565.png)

在简单的超标量CPU中，指令是按顺序发射执行的
为了更好地提高并行性能，多数超标量CPU都结合动态流水线调度技术，通过动态分支预测等手段，指令不按顺序执行，这种方式称为`乱序执行`

- **乱序执行超长指令字技术**

也称`静态多发射技术`，**`由编译程序挖掘出指令间潜在的并行性`**，**`将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字`**(可达几百位)，为此**`需要采用多个处理部件`**

- **超流水线技术**

![image-20240725212101490](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240725212101490.png)

流水线**`功能段划分得越多，时钟周期就越短，指令吞吐率也就越高`**，因此超流水线技术是**`通过提高流水线主频的方式来提升流水线性能`**的
但是，**`流水线级数越多，用于流水寄存器的开销就越大`**，因而流水线级数是有限制的，并不是越多越好

```
超流水线CPU在流水线充满后，每个时钟周期还是执行一条指令，CPI = 1，但其主频更高
多发射流水线CPU每个时钟周期可以处理多条指令，CPI < 1，但其成本更高、控制更复杂
```

---

提醒：

```
1、在流水数据通路中，时钟信号不仅作用在流水段寄存器上，还要作用在PC、各类寄存器、存储器等状态元件上
2、解决结构冒险的策略有两个方面：
	1> 一个部件每条指令只能使用一次，且只能在特定阶段使用，可以避免一部分结构冒险
	2> 通过设置多个独立的部件来避免硬件资源冲突
3、处理数据相关问题有两种方法：
	1> 暂停相关指令的执行，即暂停流水线，知道能够正确读出寄存器操作数为止
	2> 采用专门的数据通路，直接把结果送到ALU的输入端，即旁路技术
4、部分数据冒险可以通过转发技术解决，但有些数据冒险不行，如load-use类型的数据冒险(当下一条指令需要用到本条指令的访存结果时)
load-use类型的数据冒险会引起一个或多个时钟周期的阻塞，需要添加空操作指令解决
若ALU运算指令的某个操作数时分支指令转移后的执行结果，就会发生数据冒险
5、直接转移指令的转移目标地址在执行阶段才确定，会发生控制冒险
6、插入空操作可以使条件转移指令的结果在取下一条有效指令之前确定，从而避免控制冒险
7、采用转发技术们可以解决的是数据相关
8、流水段的数量越多，意味着在转移结果确定之前，可能取出更多的错误指令，从而需要更多的时间和资源来处理这些错误指令
9、分支预测用于处理控制冒险
静态预测技术假定分支总是不发生或总是发生，每次预测结果是一样的
动态预测技术根据之前条件跳转的比较结果来预测
预测错误时，已被错误放入流水线执行的指令必须被舍弃
10、超标量流水线不仅指运算操作并行，还包括取指、译码、访存、写回等其他操作，超标量技术使CPU在同一时间内执行多条指令，从而发挥更大的效率
11、超标量是指在CPU中有一条以上的流水线，并且每个时钟周期内可以完成一条以上的指令，其实质是以空间换时间，并不影响流水线功能段的处理时间
12、数据在功能部件之前传送的路径称为数据通路，包括数据通路上流经的部件，如程序计数器、ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等。数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号
```

## 多处理器的基本概念

### SISD、SIMD、MIMD的基本概念

基于`指令流的数量和数据流的数量`，将计算机体系结构分为**`SISD、SIMD、MISD和MIMD`**四类
常规的单处理器属于SISD，而常规的多处理器属于MIMD

- **单指令流单数据流(SISD)结构**

SISD是传统的**`串行计算机结构`**，这种计算机通常`仅包含一个处理器和一个存储器，处理器段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干指令`

为了提高速度，有些SISD计算机`采用流水线的方式`，因此，SISD处理器有时会设置多个功能部件，并且采用多模块交叉方式组织存储器

- **单指令流多数据流(SIMD)结构**

SIMD是指**`一个指令流同时对多个数据流进行处理`**，一般称为`数据级并行技术`

这种结构的计算机通常`由一个指令控制部件、多个处理单元组成`
**`每个处理单元虽然执行的都是同一条指令，但是每个单元都有自己的地址寄存器`**，这样**`每个单元就都有不同的数据地址`**，因此，**`不同处理单
元执行的同一条指令所处理的数据是不同的`**

一个顺序应用程序被编译后，既可能按SISD组织并运行于串行硬件上，又可能按SIMD组织并运行于并行硬件上

**`SIMD在使用for循环处理数组时最有效`**，比如，一条分别对 16 对数据进行运算的SIMD指令如果在16个ALU中同时运算，则只需要一次运算时间就能完成运算
**`SIMD在使用case或switch语句时效率最低`**，此时每个执行单元必须根据不同的数据执行不同的操作

- **多指令流单数据流(MISD)结构**

MISD是指同时执行多条指令，处理同一个数据，实际上不存在这样的计算机

- **多指令流多数据流(MIMD)结构**

MIMD是指**`同时执行多条指令分别处理多个不同的数据`**，MIMD分为**`多计算机系统和多处理器系统`**

1. **多计算机系统**中的**`每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间`**，不能通过存取指令来访问不同节点的私有存储器，而**`要通过消息传递进行数据传送`**，也称`消息传递MIMD`
2. **多处理器系统**是`共享存储多处理器(SMP)系统`的简称，它**`具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器`**，也称`共享存储MIMD`
3. **向量处理器**是SIMD的变体，是一种**`实现了直接操作一维数组(向量)指令集的CPU`**，而串行处理器只能处理单一数据集
   其基本理念是`将从存储器中收集的一组数据按顺序放到一组向量寄存器中，然后以流水化的方式对它们依次操作，最后将结果写回寄存器`。向量处理器在特定工作环境中极大地提升了性能，尤其是在数值模拟或者相似的领域中

SIMD和MIMD是两种并行计算模式，其中**`SIMD是一种数据级并行模式`**，而**`MIMD是种并行程度更高的线程级并行或线程级以上并行计算模式`**

### 硬件多线程的基本概念

在传统CPU中，线程的切换包含一系列开销，频繁地切换会极大影响系统的性能，`为了减少线程切换过程中的开销`，便诞生了硬件多线程

在支持硬件多线程的CPU中，**`必须为每个线程提供单独的通用寄存器组、单独的程序计数器等`**，**`线程的切换只需激活选中的寄存器`**，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销

硬件多线程有3种实现方式：**`细粒度多线程、粗粒度多线程和同时多线程(SMT)`**

- **细粒度多线程**

**`多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行`**
在这种方式下，**`处理器能在每个时钟周期切换线程`**

例如，在时钟周期`i`，将线程A 中的多条指令发射执行；在时钟周期`i+1`，将线程B中的多条指令发射执行

![image-20240729202803513](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240729202803513.png)

- **粗粒度多线程**

**`连续几个时钟周期都执行同一线程的指令序列，仅在当前线程出现了较大开销的阻塞时，才切换线程`**，如Cache缺失
在这种方式下，**`当发生流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线`**，因此，线程切换的开销比细粒度多线程更大

![image-20240729203055285](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240729203055285.png)

- **同时多线程**

上述两种多线程技术都实现了指令级并行，但线程级不并行，同时多线程(SMT)是上述两种多线程技术的变体
它在实现指令级并行的同时，实现线程级并行，也就是说，它**`在同一个时钟周期中，发射多个不同线程中的多条指令执行`**

![image-20240729203105168](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240729203105168.png)

Intel处理器中的超线程就是同时多线程SMT，即在一个单处理器或单个核中设置了两套线程状态部件，共享高速缓存和功能部件

### 多核处理器的基本概念

多核处理器是指**`将多个处理单元集成到单个CPU中`**，每个处理单元称为一个核(core)，通常也称`片上多处理器`

**`每个核既可以有自己的Cache，又可以共享同一个Cache`**，所有核通常共享主存储器

在多核计算机系统中，**`如要充分发挥硬件的性能，必须采用多线程(或多进程)执行，使得每个核在同一时刻都有线程在执行`**

与单核上的多线程不同，多核上的多个线程是在物理上并行执行的，是真正意义上的并行执行，在同一时刻有多个线程在并行执行
而单核上的多线程是一种多线程交错执行，实际上在同一时刻只有一个线程在执行

### 共享内存多处理器的基本概念

**`具有共享的单一物理地址空间的多处理器`**称为**共享内存多处理器(SMP)**
处理器**`通过存储器中的共享变量互相通信`**，**`所有处理器都能通过存取指令访问存储器的任何位置`**

注：`即使这些系统共享同一个物理地址空间，它们仍然可在自己的虚拟地址空间中单独地运行程序`

单一地址空间的多处理器有两种类型：

1. **统一存储访问(UMA)多处理器**。**`每个处理器对所有存储单元的访问时间是大致相同的`**，即访问时间与哪个处理器提出访存请求及访问哪个字无关
2. **非统一存储访问(NUMA)多处理器**。**`某些存储器的访存速度要比其他的快`**，具体取决于哪个处理器提出访问请求及访问哪个字，这是由于主存被分割分配给了不同处理器

由于可能会出现多个处理器同时访问同一共享变量的情况，**`在操作共享变量时需要进行同步`**，否则，一个处理器可能会在其他处理器尚未完成对共享变量的修改时，就开始使用该变量

常用方法是**`通过对共享变量加锁`**的方式来**`控制对共享变量互斥访问`**
在一个时刻只能有一个处理器获得锁，其他需要操作该共享变量的处理器必须等待，直到该处理器解锁该变量为止

在UMA构架的多处理器中，所有CPU共享同一内存空间，每个CPU的Cache都是共享内存中的一部分副本，因此多核系统的Cache一致性既包括Cache和内存之间的一致性，还包括各CPU的Cache之间的一致性，也就是说，**`对内存同一位置的数据，不同CPU的Cache不应该有不一致的内容`**

---

```
1、多核CPU的各核心既可以有独自的Cache，又可以共享一个Cache。只有支持多线程的并行处理程序才能同时再多个核心上运行，发挥多核的优势
2、多核处理器是在一颗CPU上集成了多个执行内核而非控制核心的处理器
```

## 本章小结

`指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据?`

```
从时间上讲，取指令事件发生在“取指周期”，取数据事件发生在“执行周期”
从空间上讲，从内存读出的指令流流向控制器(指令寄存器)，从内存读出的数据流流向运算器(通用寄存器)
```

`什么是指令周期、机器周期和时钟周期?它们之间有何关系?`

```
指令周期：CPU每取出并执行一条指令所需的全部时间
机器周期：在同步控制的机器执行指令周期中一步相对完整的操作(指令步)所需的时间，通常安排机器周期长度 = 主存周期
钟周期是：计算机主时钟的周期时间，是计算机运行时最基本的时序单位，对应完成一个微操作所需的时间，通常时钟周期 = 计算机主频的倒数
```

`什么是微指令?`

```
控制部件通过控制线向执行部件发出各种控制命令，通常把这种控制命令称为微命令
一组实现一定操作功能的微命令的组合，构成一条微指令
许多条微指令组成的序列构成微程序，微程序完成对指令的解释执行

指令，即指机器指令。每条指令可以完成一个独立的算术运算或逻辑运算操作
在采用微程序控制器的CPU中，一条指令对应一个微程序，一个微程序由许多微指令构成，一条微指令会发出很多不同的微命令
```

`什么是指令流水线?指令流水线相对于传统体系结构的优势是什么?`

```
指令流水线是把指令分解为若干子过程，通过将每个子过程与其他子过程并行执行，来提高计算机的吞吐率的技术
采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术，通过在同一个时间段使用各功能部件，使得利用率明显提高
```

`流水线越多，并行度就越高。是否流水段越多，指令执行越快?`

```
1、流水段缓冲之间的额外开销增大
每个流水段有一些额外开销用于缓冲间传送数据、进行各种准备和发送等功能，这些开销加长了一条指令的整个执行时间，当指令间逻辑上相互依赖时，开销更大
2、流水段间控制逻辑变多、变复杂
用于流水线优化和存储器(或寄存器)冲突处理的控制逻辑将随流水段的增加而大增，这可能导致用于流水段之间控制的逻辑比段本身的控制逻辑更复杂
```

`读后写(WAR)相关和写后写(WAW)相关的概念`

```
读后写(WAR)冲突。表示当前指令读出数据后，下一条指令才能写该寄存器。否则，先写后读，读到的就是错误(新)数据
写后写(WAW)相关。表示当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值

在非按序执行的流水线中，因为允许后进入流水线的指令超过先进入流水线的指令而先流出流水线，所以既可能发生RAW相关，又可能发生WAR和WAW相关
```

