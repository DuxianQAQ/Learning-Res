# 存储系统

**考纲内容**

- 存储器的分类
- 层次化存储器的基本结构
- 半导体随机存储器(RAM)
  SRAM、DRAM、Flash存储器
- 主存储器
  DRAM芯片和内存条、多模块存储器、主存储器和CPU之间的连接
- 外部存储器
  磁盘存储器、固态硬盘(SSD)
- 高速缓冲存储器(Cache)
  Cache的基本原理：Cache和主存之间的映射方式
  Cache中主存块的替换算法；Cache写策略
- 虚拟存储器
  虚拟存储器的基本概念
  页式虚拟存储器：基本原理、页表、地址转换、TLB(快表)
  段式虚拟存储器的基本原理；段页式虚拟存储器的基本原理

有关Cache和虚拟存储器的看i熬点容易出综合题
存储器的特点，存储器的扩展(芯片选择、链接方式、地址范围等)，交叉存储器，Cache的相关计算与替换算法，虚拟存储器与TLB也容易出选择题
另外，需掌握存在Cache和TLB的计算机中的地址翻译与Cache映射问题

思考以下问题：

```
1、存储器系统为何要分这些层次？计算机如何管理这些层次？
2、影响Cache性能的因素右哪些？
3、虚拟存储系统的页面时设置得大一些好还是小一些好？
```

## 存储器概述

### 存储器的分类

#### 按在计算机中的作用(层次)分类

- **主存储器**。简称`主存`，也称`内存储器(内存)`，用来**`存放计算机运行期间所需的程序和数据`**
  **`CPU可以直接随机地对其进行访问，也可以和高速缓冲存储器(Cache)及辅助存储器交换数据`**
  其特点是**`容量较小、存取速度较快、每位的价格较高`**
- **辅助存储器**。简称`辅存`，也称`外存储器`或`外存`，用来**`存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息`**
  辅存的内容**`需要调入主存后才能被CPU访问`**
  其特点是**`容量大、存取速度较慢、单位成本低`**
- **高速缓冲存储器**。简称`Cache`，**`位于主存和CPU之间`**，用来**`存放当前CPU经常使用的指令和数据，以便CPU能高速地访问它们`**
  Cache的存取速度可与CPU的速度相匹配，但**`存储容量小、价格高`**

#### 按存储介质分类

按存储介质，存储器可分为`磁表面存储器`(磁盘、磁带)、`磁芯存储器`、`半导体存储器`(MOS型存储器、双极型存储器)和`光存储器`(光盘)

#### 按存取方式分类

- **随机存储器(RAM)**。**`存储器的任何一个存储单元都可以随机存取，而且存取时间与存储单元的物理位置无关`**
  优点：**`读/写方便、使用灵活，主要用作主存或高速缓冲存储器`**
  RAM又分静态RAM和动态RAM，后续介绍
- **只读存储器(ROM)**。存储器的内容**`只能随机读出而不能写入`**
  **`信息一旦写入存储器就固定不变`**，即使断电，内容也不会丢失。因此，通常用它存放固定不变的程序、常数和汉字字库等
  **`ROM与随机存储器可共同作为主存的一部分，统一构成主存的地址域`**
  由ROM派生出的存储器也包含可反复重写的类型，**`ROM和RAM的存取方式均为随机存取`**
  广义上的只读存储器已可通过电擦除等方式进行写入，其“只读”的概念没有保留，但仍保留了断电内容保留、随机读取特性，但其写入速度比读取速度慢得多
- **串行访问存储器**。**`对存储单元进行读/写操作时，需按其物理位置的先后顺序寻址`**，包括**`顺序存取存储器`**(如磁带)和**`直接存取存储器`**(如磁盘、光盘)
  **`顺序存取存储器的内容只能按某种顺序存取`**，存取时间的⻓短与信息在存储体上的物理位置有关，其特点是**`存取速度慢`**
  **`直接存取存储器`**既不像RAM那样随机地访问任何一个存储单元，又不像顺序存取存储器那样完全按顺序存取，而是介于两者之间。**`存取信息时通常先寻找整个存储器中的某个小区域`**(如磁盘上的磁道)，**`再在小区域内顺序查找`**

#### 按信息的可保存性分类

断电后，存储信息即消失的存储器，称为`易失性存储器`，如RAM
断电后，信息仍然保持的存储器，称为`非易失性存储器`，如ROM、磁表面存储器和光存储器

若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为`破坏性读出`
若读出时，被读单元原存储信息不被破坏，则称为`非破坏性读出`
具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息

### 存储器的性能指标

存储器有三个主要性能指标，即**`存储容量、单位成本和存储速度`**。这三个指标相互制约，设计存储器系统所追求的目标就是大容量、低成本和高速度

- **存储容量**：**`存储容量 = 存储字数 x 字⻓`**
  单位换算：1B(字节) = 8b(位)
  **`存储字数表示存储器的地址空间大小，字⻓表示一次存取操作的数据量`**
- **单位成本**：`每位价格 = 总成本 / 总容量`
- **存储速度**：**`数据传输速率(每秒传送信息的位数) = 数据的宽度 / 存取周期`**

1、**存取时间(T~a~)**：存取时间是指**`从启动一次存储器操作到完成该操作所经历的时间`**，分为`读出时间和写入时间`
2、**存取周期(T~m~)**：存取周期是指**`存储器进行一次完整的读/写操作所需的全部时间`**，即**`连续两次独立访问存储器操作(读或写操作)之间所需的最小时间间隔`**
3、**主存带宽(B~m~)**：也称`数据传输速率`，表示**`每秒从主存进出信息的最大数量`**，单位为字/秒、字节/秒(B/s)或位/秒(b/s)

存取时间不等于存取周期，通常**`存取周期大于存取时间`**。这是因为对任何一种存储器，在读/写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，甚至可达T~m~ = 2T~a~，因为存储器中的信息读出后需要⻢上进行再生

![image-20240613104636757](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240613104636757.png)

### 多级层次的存储系统

为了解决存储系统大容量、高速度和低成本这三个相互制约的矛盾，在计算机系统中，通常采用多级存储器结构

![image-20240613104737992](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240613104737992.png)

在上图**`由上至下，位价越来越低，速度越来越慢，容量越来越大，CPU访问的频度也越来越低`**

实际上，存储系统层次结构主要体现在`Cache ~ 主存层`和`主存 ~ 辅存层`

在存储体系中，**`Cache、主存能与CPU直接交换信息`**，**`辅存则要通过主存与CPU交换信息`**，**`主存与CPU、Cache、辅存都能交换信息`**

![image-20240613104929136](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240613104929136.png)

存储器层次结构的主要思想是**`上一层的在储器作为低一层在储器的高速缓存`**

当CPU要从存储器中存取数据时，先访问Cache，若不在Cache中，则访问主存，若不在主存中，则访问磁盘，此时，操作数从磁盘读出送到主存，然后从主存送到Cache

从CPU的⻆度看，Cache ~ 主存层的速度接近于Cache，容量和位价却接近于主存
从主存 ~ 辅存层分析，其速度接近于主存，容量和位价却接近于辅存
这样就解决了速度、容量、成本这三者之间的矛盾

**`Cache ~ 主存层主要解决CPU和主存速度不匹配的问题`**，主存和Cache之间的数据调动是由硬件自动完成的，对所有程序员均是透明的
**`主存 ~ 辅存层主要解决存储系统的容量问题`**，主存和辅存之间的数据调动是由硬件和操作系统共同完成的，对应用程序员是透明的

注：`在Cache - 主存层和主存 - 辅存层中，上一层中的内容都只是下一层中的内容的副本，也即Cache(或主存)中的内容只是主存(或辅存)中的内容的一部分`

---

提醒：

```
1、主存和辅存之间的数据调用是由硬件和操作系统共同完成的，仅对应用级程序员透明
2、随机存取是指CPU可对存储器的任意一个存储单元中的内容随机存取，而且存取时间与存储单元的物理位置无关
3、CD-ROM即光盘，采用串行存取方式(直接存取)
```

## 主存储器

把存放一个二进制位的物理器件称为`存储元`，它是存储器的最基本的构件
地址码相同的多个存储元构成一个`存储单元`
若干存储单元的集合构成`存储体`

---

半导体存储器分为**`随机存储器(RAM)`**和**`只读存储器(ROM)`**
**`RAM为易失性存储器；ROM为非易失性存储器`**

其中，RAM又分为**`静态随机存储器(SRAM)`**和**`动态随机存储器(DRAM)`**

### SRAM芯片和DRAM芯片

SRAM，即动态随机存储器；DRAM，即静态随机存储器
**`SRAM用于Cache；DRAM用于主存`**
SRAM使用`双稳态触发器`存储信息；DRAM使用`栅极电路`存储信息
SRAM和DRAM都是**`易失性存储器`**，**`断电后信息将会消失`**

- **SRAM**

静态随机存储器(SRAM)的存储元是**`用双稳态触发器(六晶体管MOS)来记忆信息`**的
**静态**：读出数据，触发器状态保持稳定，是**`非破坏性读出`**，仍保持其原状态不需要再生，**`无需重写`**

相较于DRAM，SRAM的**`存取速度快`**，每个存储元**`制造成本更高`**，**`集成度低`**，**`功耗大`**，**`一般用于高速缓冲存储器(Cache)`**

对于双稳态触发器，只要不断电，触发器的状态就不会改变，因此**`不需要进行刷新操作`**

- **DRAM**

动态随机存储器(DRAM)是**`利用存储元电路中栅极电容上的电荷来存储信息`**的
**动态**：读操作时，电容放电，电容信息被破坏，使其状态发生改变(**`破坏性读出`**)，需读后再生，即**`读出后重写`**

相较于SRAM，DRAM的**`存取速度慢`**，每个存储元**`制造成本更低`**，**`集成度高`**，**`功耗低`**，**`一般用于主存`**

对于电容，电容内的电荷只能维持很短的时间(2ms)，即使不断电，随着时间的推移信息也会消失，因此**`必须进行刷新操作`**(给电容充电)

#### DRAM的刷新

由于DRAM电容上的电荷一般只能维持1 ~ 2ms，因此**`必须在一个刷新周期内刷新至少一次`**
**`每次刷新都以行为单位`**，**`每次刷新一行存储单元`**

刷新可以采用读出的方法进行，**`根据读出内容对相应单元进行重写`**，即`读后再生`
对同一进行相邻两次刷新的时间间隔称为`刷新周期`，通常取`2ms`

常用的刷新方式有以下3种：

1. **集中刷新**：在**`一个刷新周期内`**，**`利用一段固定的时间，依次对存储器的所有行进行逐一再生`**，在此期间**`停止对存储器的读/写操作`**，称为`死时间`，也称`访存死区`
   优点：**`读/写操作时不受刷新工作的影响`**
   缺点：**`在集中刷新期间(死区)不能访问存储器`**
2. **分散刷新**：将一个存储器系统的工作周期分为两部分：**`前半部分用于正常的读/写操作`**；**`后半部分用于刷新`**
   优点：**`没有死区`**
   缺点：**`加长了系统的存取周期`**
3. **异步刷新**：结合了前两种方法，使得**`在一个刷新周期内每一行仅刷新一次`**
   将`刷新周期除以行数`得到`相邻两行之间刷新的时间间隔t`，每隔时间`t`产生一次刷新请求。这样就使**`“死时间”的分布更加分散，避免让CPU连续等待过长的时间`**

![image-20240617164307361](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240617164307361.png)

DRAM的刷新需要注意以下问题：

1. **`刷新由存储器独立完成，不需要CPU控制`**
2. **`DRAM的刷新单位是行`**，由芯片内部自行生成行地址
3. 刷新操作类似于读操作，但又有所不同
4. 刷新时不需要选片，即**`整个存储器中的所有芯片同时被刷新`**

注：`DRAM的刷新和再生都是恢复数据。刷新是以行为单位，逐行恢复数据的；再生仅需恢复被读出的那些单元的数据`

#### 存储器芯片的内部结构

存储芯片由`存储体、I/O读/写电路、地址译码器和控制电路`等部分组成，如下所示：

![image-20240613211222776](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240613211222776.png)

1. **存储体**(存储矩阵)。存储体是存储单元的集合，它**`由行选择线(X)和列选择线(Y)来选择所访问单元`**，**`存储体的相同行、列上的多位(位平面数)同时被读出或写入`**
2. **地址译码器**。用来**`将地址转换为译码输出线上的高电平，以便驱动相应的读/写电路`**。地址译码有单译码法(一维译码)和双译码法(二维译码)两种方式：
   1> **单译码法**。只有**`一个行译码器`**，**`同一行中所有存储单元的字线连在一起，同一行中的各单元构成一个字，被同时读出或写入`**。缺点是**`地址译码器的输出线数过多`**
   2> **双译码法**。如上例图所示，**`地址译码器分为X和Y方向两个译码器，在选中的行和列交叉点上能确定一个存储单元`**，这是DRAM 芯片目前普遍采用的译码结构
3. **I/O控制电路**。用以**`控制被选中的单元的读出或写入，具有放大信息的作用`**
4. **片选控制信号**。单个芯片容量太小，往往满足不了计算机对存储器容量的要求，因此**`需用一定数量的芯片进行存储器的扩展`**。**`在访问某个字时，必须“选中”该存储字所在的芯片，而其他芯片不被“选中”，因此需要有片选控制信号`**
5. **读/写控制信号**。**`根据CPU给出的读命令或写命令，控制被选中单元进行读或写`**

#### DRAM的地址复用技术

![image-20240617165338210](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240617165338210.png)

**`行、列地址分两次送出`**，可以**`使地址线减半`**，以及使芯片引脚的数量更小

#### DRAM芯片的读/写周期

DRAM芯片读/写周期的时序图如下所示：

![image-20240613210827216](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240613210827216.png)

为了使芯片能正确接收行、列地址并实现读/写操作，各信号的时间关系应符合一定要求
读(写)周期时间 **t~RC~**(**t~WC~**) 表示`DRAM芯片进行两次连续读(写)操作时所必须间隔的时间`

- 在读周期中，在RAS有效前将行地址送到芯片的地址引脚，CAS滞后RAS一段时间，在CAS有效前再将列地址送到芯片的地址引脚，RAS、CAS应分别至少保持 **t~RAS~**(**t~CAS~**) 的时间。在读周期WE为高电平，并在CAS有效前建立
- 在写周期中，行列选通信号的时序关系和读周期相同。在写周期中WE为低电平，同样在CAS有效前建立。为保证数据可靠的写入，写数据必须在CAS有效前在数据总线上保持稳定

#### SRAM和DRAM的比较

![image-20240617110322030](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240617110322030.png)

#### SDRAM

目前更常用的是SDRAM(同步DRAM)芯片

**`DRAM与CPU采用异步方式交换数据`**，CPU发出地址和控制信号后，经过一段延迟时间，数据才读出或写入，**`在读/写完成之前，CPU不能做其他工作`**

**`SDRAM与CPU采用同步方式交换数据`**，它**`将CPU发出的地址和控制信号锁存起来`**，**`CPU在其读/写完成之前可进行其他操作`**。SDRAM的**`每一步操作都在系统时钟的控制下进行`**，支持**突发传输方式**，即**`在寻址阶段发送数据单元的首地址在传输阶段传送多个连续单元的数据`**
第一次存取时给出首地址，同一行的所有数据都被送到行缓存器，因此以后每个时钟都可以连续地从SDRAM输出一个数据
**`行缓存器用来缓存指定行中整行的数据`**，其大小为**`列 x 位平面数`**，通常用SRAM实现

### 只读存储器

- **MROM：掩模式只读存储器**
  MROM的内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，**`写入以后任何人都无法改变其内容`**
  优点：**`可靠性高，集成度高，价格便宜`**
  缺点：**`灵活性差`**
- **PROM：一次可编程只读存储器**
  PROM是可以实现一次性编程的只读存储器。允许用户利用专门的设备(编程器)写入自己的程序，**`一旦写入，内容就无法改变`**
- **EPROM：可擦除可编程只读存储器**
  EPROM允许用户写入信息，之后可用某种方法擦除数据，**`可以对其内容进行多次改写`**
  EPROM虽然既可读又可写，但它不能取代RAM，因为**`EPROM的编程次数有限，且写入时间过长`**
  **UVEPROM：紫外线可擦除可编程只读存储器**
  用紫外线来进行擦除，一般**`擦除的是存储器内的所有信息`**
  **EEPROM(E^2^PROM)：可电擦除可编程只读存储器**
  用电擦除的方式来进行擦除，一般**`擦除的是存储器内特定的字`**
- **Flash Memory：闪速存储器(闪存)**：如U盘，SD卡
  Flash存储器是在EPROM的基础上发展起来的，**`可在不加电的情况下长期保存信息，又能在线进行快速擦除与重写`**
  **`可进行多次快速擦除重写`**
  由于**`闪存需要先擦除在写入，因此闪存的写速度要比读速度要慢`**
  闪存的存储元只需要使用单个MOS管，**`位密度会比RAM高`**
- **SSD：固态硬盘**
  由控制单元 + 存储单元(Flash芯片)构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，**`可进行多次快速擦除重写`**
  保留了Fash存储器**`长期保存信息、快速擦除与重写`**的特性；对比传统硬盘也具有**`读/写速度快、低功耗`**的特性
  缺点是**`价格较高`**

**只读存储器(ROM)的特点**

ROM和RAM都是**`支持随机访问`**的存储器，**`ROM 中一旦有了信息，就不能轻易改变`**，即使掉电也不会丢失，属于**`非易失性随机存储器`**

ROM具有两个显著的优点：

1. **`结构简单`**，所以**`位密度比可读/写存储器的高`**
2. **`具有非易失性`**，所以**`可靠性高`**

---

**计算机中重要的ROM(BIOS)**

```
计算机的主存是用来存放一系列的指令和数据的，CPU的任务就是从主存中取指令并执行指令
由于RAM芯片是一种易失性芯片，断电后RAM内数据全部丢失，在计算机关机之后其中的数据全部会消失

当再一次开机的时候，CPU需要把操作系统以及应用程序相关的一些指令或数据重新调入主存，而操作系统都是安装在辅存中的
CPU会调用主板上的ROM芯片上来读取开机的一系列指令和数据，这块ROM芯片即为BIOS芯片，其中存储了自举装入程序，负责引导装入操作系统(开机)

自举装入程序：CPU在开机时执行的那一段程序，根据这一段程序的指引，CPU能够指挥I/O系统将辅存中存储的操作系统相关的数据放到主存中

注意：逻辑上，主存是由RAM+ROM组成，即内存条(RAM)+BIOS芯片(ROM)，且二者统一编制
统一编制：主存中的首地址是先分配给BIOS芯片的，往后继续才是内存条的地址
```

### 主存储器的基本组成

如下所示为**主存储器(MM)**的基本框图，其中由一个个存储0或1的`记忆单元(也称存储元件)`构成的`存储矩阵(也称存储体)`是存储器的核心部件
存储元件是具有两种稳态的能表示二进制0和1的物理器件
**`为了存取存储体中的信息，必须对存储单元编号(也称编址)`**
`编址单位`是指具有相同地址的那些存储元件构成的一个单位，可以按字节编址，也可以按字编址
现代计算机通常采用字节编址方式，此时存储体内的一个地址中有1字节

![image-20240614101828177](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240614101828177.png)

指令执行过程中需要访问主存时：

1. CPU首先把被访问单元的地址送到MAR中
2. 然后通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码，选中相应单元，同时CPU将读/写信号通过控制线送到主存的读/写控制电路
   若是**`写操作`**，则**`CPU同时将要写的信息送到MDR中`**，**`在读/写控制电路的控制下，经数据线将信号写入选中的单元`**
   若是**`读操作`**，则**`主存读出选中单元的内容送至数据线，然后被送到MDR中`**

**`MDR的位数与数据线的位数相同，MAR的位数与地址线的位数相同`**

如上所示，采用64位数据线，所以在按字节(8bit)编址方式下，每次最多可以存取8(64/8)个单元的内容
地址线的位数决定了主存地址空间的最大可寻址范围。例如，36位地址的最大寻址范围为0 ~ 2^36^ - 1，地址从0开始编号

注：`数据线的位数通常等于存储字长，因此MDR的位数通常等于存储字长；若数据线的位数不等于存储字长，则MDR的位数由数据线的位数决定`

DRAM芯片容量较大，地址位数较多，**`为了减少芯片的地址引脚数`**，通常采用**`地址引脚复用技术`**，**`行地址和列地址通过相同的引脚分先后两次输入，这样地址引脚数可减少一半`**

假定有一个**2^n^ x b**位DRAM芯片的存储阵列，其行数为**r**，列数为**c**，则**2^n^ = r x c**。存储阵列的地址位数为**n**，其中行地址位数为**log~2~r**，列地址位数为**log~2~c**，则**n = log~2~r + log~2~r**

由于DRAM芯片采用地址引脚复用技术，**`为减少地址引脚数，应尽量使行、列位数相同`**，即**`满足 |r - c| 最小`**
又由于DRAM按行刷新，**`为减少刷新开销，应使行数较少`**，因此还需**`满足r ≤ c`**













### 多模块存储器

**存取周期**

![image-20240618101001994](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240618101001994.png)

存取周期即可以连续读/写的最短时间间隔

注：`DRAM芯片的恢复时间比较长，有可能是存取时间的几倍(SRAM的恢复时间较短)`

#### 双端口RAM

双端口RAM能够**`优化多核CPU访问一根内存条的速度`**

需要有两组完全独立的数据线、地址线、控制线。CPU、RAM中也要由更复杂的控制电路

![image-20240618101559597](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240618101559597.png)

两个端口对同一主存操作有以下4种情况：

1. 两个端口同时对不同的地址单元存取数据
2. 两个端口同时对同一地址单元读出数据
3. 两个端口同时对同一地址单元写入数据，非法操作，发生写入错误
4. 两个端口同时对同一地址端元，一个写入数据，另一个读出数据，非法操作，发生读出错误

发生错误时，应置忙信号为0，由判断逻辑决定暂时关闭一个端口(延时)，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问

#### 单体多字存储器

在单体多字系统中，**`每个存储单元存储m个字，总线宽度也为m个字，一次并行读出m个字`**
在**`一个存取周期内`**，从**`同一地址取出m条指令`**，将指令逐条送至CPU执行，即**`每隔1/m存取周期，CPU向主存取一条指令`**
这显然提高了单体存储器的工作速度

实际上这种方式相当于把m个内存条整合起来了，每次都读取每一个内存条中的第一个地址，总共有m个，因此读取了m个字

缺点：只有**`指令和数据在主存中连续存放时，这种方法才能有效提升存取速度`**。一旦遇到转移指令，或操作数不能连续存放时，这种方法的提升效果就不明显

#### 多体并行存储器

多体并行存储器由多体模块组成。**`每个模块都有相同的容量和存取速度，各模块都有独立的读/写控制电路、地址寄存器和数据寄存器`**，可以理解为有多跟内存条。它们**`既能并行工作，又能交叉工作`**

多体并行存储器分为**`高位交叉编址`**和**`低位交叉编址`**两种

- **高位交叉编址(顺序方式)**

**`高位地址表示模块号(或体号)，低位地址为模块内地址(或体内地址)`**
即高位用来区分访问的是哪根内存条，低位则用来表示访问的是内存条中的地址
高位的表示用二进制数字表示，若有4根内存条，则为00、01、10、11，总共占用两位二进制位

访问一个连续主存块时，**`总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问`**
高位交叉编制的特点是地址按照一条一条内存条来编排，一条内存条编满后才向下一个内存条进行编排

![image-20240614104729973](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240614104729973.png)

如上所示，存储器共有4个模块M~0~ ~ M~3~，每个模块有n个单元，各模块的地址范围如图中所示

在高位交叉方式下，**`总把低位的体内地址送到由高位体号确定的模块内进行译码`**
**`CPU总是按顺序访问存储模块，各模块不能被并行访问，因而不能提高存储器的吞吐率`**

设每个存储体存取周期为T，其中存取时间为r，假设T = 4r，当访问5个连续的地址时，会有：

![image-20240618103808167](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240618103808167.png)

总共耗时5T，其中每个T中有r用来访问数据，剩下的3r则为等待恢复时间，被浪费了，这种访问方式效率很低

注：`模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是顺序存储器`

- **低位交叉编址(交叉方式)**

低位地址为模块号，高位地址为模块内地址
地位与高位正好相反，高位用来表示访问的是内存条中的地址，地位用来区分访问的是哪根内存条，表示方式与高位类似

低位交叉编制的特点是地址是横向编排的，按照内存条的数量来依次从小到大编排，同一内存条的上下两个地址之间相差内存条数量个地址

![image-20240614105055140](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240614105055140.png)

如上所示，**`每个块按模m交叉编址`**，**`模块号 = 单元地址 % m`**
假定有`m个模块`，每个模块有`k个单元`，则单元`0，m，……，(k-1)m`位于M~0~；单元`1，m+1，…，(k-1)m+1`位于 M~1~；以此类推

低位交叉方式下，总是**`把高位的体内地址送到由低位体号所确定的模块内进行译码`**
程序连续存放在相邻模块中，因此称采用此编址方式的存储器为`交叉存储器`

交叉存储器可以采用**`轮流启动`**或**`同时启动`**两种方式

- **轮流启动方式**

若**`每个模块一次读/写的位数正好等于数据总线位数`**，模块的`存取周期为T`，`总线周期为r`，为实现轮流启动方式，存储器交叉模块数应大于或等于**`m = T / r`**

按**`每隔1/m个存取周期轮流启动各模块`**，则**`每隔1/m个存取周期就可读出或写入一个数据`**，存取速度提高m倍

![image-20240614105945205](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240614105945205.png)

上图展示了4体交叉轮流启动的时间关系

**`交叉存储器要求其模块数大于或等于m`**，以**`保证启动某模块后经过mxr的时间后再次启动该模块时，其上次的存取操作已经完成`**
这样，连续存取m个字所需的时间为**`t1 = T + (m - 1)r`**
而顺序方式连续读取m个字所需的时间为**`t2 = mT`**
**`交叉存储器的带宽大大提高`**

当模块数**`m < T / r`**时，CPU需要等待

![image-20240618105101287](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240618105101287.png)

当模块数**`m > T / r`**时，模块会有闲置时间

![image-20240618105108501](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240618105108501.png)

因此最好使得**`m = T / r`**

![image-20240618105222330](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240618105222330.png)

在理想情况下，**`m体交叉存储器每隔1/m存取周期可读/写一个数据`**，若**`相邻的m次访问的访存地址出现在同一个模块内，则会发生访存冲突`**，此时**`需延迟发生冲突的访问请求`**

- **同时启动方式**

若**`所有模块一次并行读/写的总位数正好等于数据总线位数`**，则**`可以同时启动所有模块进行读/写`**

设每个模块一次读/写的位数正好为16位，模块数m = 4，数据总线位数为64位，4个模块一共提供64位，正好构成一个存储字，因此应该同时启动4个模块进行并行读/写

---

提醒：

```
1、分散刷新不存在死时间，机器的存取周期中的一段用来读/写，另一段用来刷新，不存在死时间，但存取周期变长
2、RAM属于易失性半导体，SRAM和DRAM的区别在于是否需要动态刷新
3、主存由RAM和ROM构成，两者统一编址
4、同一种存储器中，每个存储单元的宽度必须相同，即每个存储的比特位数必须相同
5、Cache由SRAM组成，掉电之后信息将会消失，属于易失性存储器
6、U盘采用Flash存储器技术，属于ROM的一种
7、操作系统保存于硬盘需要BIOS的引导程序，将操作系统引导到主存(RAM)中，而引导程序则固化于ROM中
8、采用地址复用技术，行地址和列地址分时复用，每增加1根地址线，行地址和列地址各增加1位，因此容量会增加到原来的4倍
9、单体多字存储器主要解决访存速度的问题
10、闪存是ROM的一种，写入时必须先擦除原有数据，所以写速度要比读速递慢
11、DRAM按行刷新，若要减少刷新开销，应当使行数尽量少
```

## 主存储器与CPU的连接

### 连接原理

1. 主存储器通过**`数据总线、地址总线、控制总线`**与CPU连接
2. **`数据总线的位数与工作频率的乘积正比于数据传输速率`**
3. **`地址空间的位数决定了可寻址的最大内存空间`**
4. **`控制总线(读/写)指出总线周期的类型和本次输入/输出操作完成的时刻`**

![image-20240620101139570](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240620101139570.png)

单芯片的容量是有限的，因此通过`存储器芯片扩展技术`，将多个芯片集成在一个内存条上，然后由多个内存条及主板上的ROM芯片组成计算机所需的主存空间，再通过总线与CPU相连

### 主存容量的扩展

由于单个存储芯片的容量是有限的，它在字数或字长方面与实际存储器的要求都有差距，因此需要在字和位两方面进行扩充才能满足实际存储器的容量要求

#### 位扩展法

位扩展是指**`对字长进行扩展(增加存储字长)`**。当**`CPU的系统数据线多于存储芯片的数据位数`**时，必须**`对存储芯片扩位`**，**`使其数据位数与CPU的数据线数相等`**

位扩展的连接方式：各芯片的地址线、片选线、读/写控制线与系统总线相应并联；各芯片的数据线单独引出，分别连接系统数据线。**`各芯片同时工作`**

![image-20240620105033820](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240620105033820.png)

如上所示，用8片`8K x 1位`的RAM芯片组成`8K x 8位`的存储器，8K = 2^13^，共13条地址线，对应A~0~ ~ A~12~
8片RAM芯片的地址线A~0~ ~ A~12~、CS、WE都分别连在一起，每片的数据线依次作为CPU数据线的一位

简单来说，位扩展就是`前不变后变`

#### 字扩展法

字扩展是指**`对存储字的数量进行扩展，而存储字的位数满足系统要求`**。**`系统数据线位数等于芯片数据线位数，系统地址线位数多于芯片地址线位数`**

字扩展的连接方式：各芯片的地址线与系统地址线的低位对应相连；芯片的数据线和读/写控制线与系统总线相应并联；由系统地址线的高位译码得到各芯片的片选信号。**`各芯片分时工作`**

![image-20240620105813794](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240620105813794.png)

如上所示，用4片`16K x 8位`的RAM芯片组成`64K x 8位`的存储器
4片RAM芯片的数据线D~0~ ~ D~7~和WE都分别连在一起
将A~15~A~14~用作片选信号，两位正好对应4种情况，根据译码器翻译出来是几，就选哪一号芯片，如上例中：

第一片：最低地址：00 00 0000 0000 0000；最高地址：00 11 1111 1111 1111
第二片：最低地址：01 00 0000 0000 0000；最高地址：01 11 1111 1111 1111
第三片：最低地址：10 00 0000 0000 0000；最高地址：10 11 1111 1111 1111
第四片：最低地址：11 00 0000 0000 0000；最高地址：11 11 1111 1111 1111

简单来说，字扩展就是`前变后不变`，其中**`高位用于片选`**

#### 字位同时扩展法

字位同时扩展是前两种扩展的组合，这种方式**`既增加存储字的数量，又增加存储字长`**

字位同时扩展的连接方式：将进行位扩展的芯片作为一组，各组的连接方式与位扩展的相同；由系统地址线高位译码产生若干片选信号，分别接到各组芯片的片选信号

![image-20240620111445881](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240620111445881.png)

如上所示，用8片`16K x 4位`的RAM芯片组成`64K x 8位`的存储器
每两片构成一组`16K x 8位`的存储器(位扩展)，4组便构成`64K x 8位`的存储器(字扩展)
地址线A~15~A~14~经译码器得到4个片选信号，用来选中不同的芯片组

### 存储芯片的地址分配和片选

CPU要实现对存储单元的访问，首先要选择存储芯片，即进行**片选**
然后在选定的芯片中选择具体的存储单元，以进行数据的读/写，即进行**字选**
芯片内的**`字选通常是由CPU送出的N条低位地址线完成`**(N由片内存储容量 2^N^ 决定)

片选信号的产生方法分为**`线选法`**和**`译码片选法`**

#### 线选法

线选法用除片内寻址外的高位地址线直接连接至各个存储芯片的片选端，**`当某位地址线信息为0时，就选中与之对应的存储芯片`**

这些片选地址线**`每次寻址时只能有一位有效`**，**`不允许同时有多位有效`**，这样才能保证每次只选中一个芯片(或芯片组)

优点：不需要地址译码器，线路简单
缺点：地址空间不连续，选片的地址线必须分时为低电平(否则不能工作)，不能充分利用系统的存储器空间，造成地址资源浪费

![image-20240624201932133](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240624201932133.png)

注：`除非题目有特别说明，不然选用芯片所用的位一律从高到低`

#### 译码片选法

译码片选法用除片内寻址外的高位地址线通过地址译码器产生片选信号

不同于线选法的是译码片选法**`加入了译码器，可以翻译高位`**，看选定的是哪个芯片

![image-20240624202941578](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240624202941578.png)

### 存储器与CPU的连接

- **合理选择存储芯片**

要组成一个主存系统，选择存储芯片是第一步，主要指存储芯片的类型(RAM或ROM)和数量的选择

通常选用ROM存放系统程序、标准子程序和各类常数
RAM则是为用户编程而设置的

- **地址线的连接**

存储芯片的容量不同，其地址线也不同，而**`CPU的地址线数往往比存储芯片的地址线数要多`**

通常将CPU地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元(字选)，这部分的译码是由芯片的片内逻辑完成的
而CPU地址线的高位则在扩充存储芯片时使用，用来选择存储芯片(片选)，这部分译码由外接译码器逻辑完成

- **数据线的连接**

CPU的数据线与存储芯片的数据线不一定相等，在**`相等时可直接连接`**；在**`不等时必须对存储芯片扩位，使其数据位数与CPU的数据线相等`**

- **读/写命令线的连接**

CPU读/写命令线一般可直接与存储芯片的读/写控制端相连，通常为高电平为读，低电平为写

有些CPU的读/写命令线是分开的，此时CPU的读命令线与芯片的允许读控制端相连，而CPU的写命令线则应与芯片的允许写控制端相连

- **片选线的连接**

片选线的连接是CPU与存储芯片连接的关键。存储器由许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端是否能接收来自CPU的片选有效信号

---

提醒：

```
1、考虑到存储器需扩展的需要，MAR应保证能访问到整个主存地址空间，即MAR的位数决定了主存地址空间的大小
```

## 外部存储器

### 磁盘存储器

磁盘存储器是以磁盘为存储介质的存储器，其主要优点：

1. **`存储容量大，位价格低`**
2. 记录**`介质可以重复使用`**
3. 记录**`信息可以长期保存`**而不丢失，甚至可脱机存档
4. **`非破坏性读出`**，读出时不需要再生

缺点：**`存取速度慢`**，机械结构复杂，对工作环境要求较高

#### 磁盘存储器

- **磁盘设备的组成**

**磁盘存储器的组成**

磁盘存储器由**`磁盘驱动器、磁盘控制器和盘片`**组成

**磁盘驱动器**。驱动磁盘转动并在盘面上通过磁头进行读/写操作的装置
**磁盘控制器**。磁盘驱动器与主机的接口，负责接收并解释CPU发来的命令，向磁盘驱动器发出各种控制信号，并负责检测磁盘驱动器的状态

![image-20240626210852523](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240626210852523.png)

---

**存储区域**

**磁头数**：即记录面数，表示磁盘共有多少个磁头，**`磁头用于读取/写入盘片上记录面的信息`**，**`一个记录面对应一个磁头`**
**柱面数**：表示磁盘每面盘片上有多少条磁道。在一个盘组中，**`不同记录面的相同编号(位置)的诸磁道构成一个圆柱面`**
**扇区数**：表示每条磁道上有多少个扇区

相邻磁道及相邻扇区间通过一定的间隙分隔开，以**`避免精度错误`**
由于扇区按固定圆心角度划分，因此**`位密度从最外道向里道增加`**，磁盘的**`存储能力受限于最内道的最大记录密度`**

---

**磁盘高速缓存**

在内存中开辟一部分区域，**`用于缓冲将被送到磁盘上的数据`**

优点：写磁盘时是按“簇”进行的，**`可以避免频繁地用小块数据写盘`**；有些**`中间结果数据在写回磁盘之前可被快速地再次使用`**

- **磁记录原理**

原理：磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作

编码方法：按某种方案(规律)，把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并**`使读/写控制电路容易、可靠地实现转换`**

磁记录方式：通常采用调频制(FM)和改进型调频制(MFM)的记录方式

- **磁盘的性能指标**

1. **记录密度**。记录密度是指**`盘片单位面积上记录的二进制信息量`**，通常以道密度、位密度和面密度表示
   `道密度`是**`沿磁盘半径方向单位长度上的磁道数`**
   `位密度`是**`磁道单位长度上能记录的二进制代码位数`**
   `面密度`是**`位密度和道密度的乘积`**

2. **磁盘的容量**。磁盘容量有**`非格式化容量和格式化容量`**之分

   `非格式化容量`是指**`磁记录表面可利用的磁化单元总数`**，`非格式化容量 = 记录面数 x 柱面数 x 每条道的磁化单元数`
   `格式化容量`是指**`按照某种特定的记录格式所能存储信息的总量`**。`格式化容量 = 记录面数 x 柱面数 x 每道扇区数 x 每个扇区的容量`
   **`格式化后的容量比非格式化容量要小`**

3. **存取时间**。存取时间由**`寻道时间`**(磁头移动到目的磁道的时间)、**`旋转延迟时间`**(磁头定位到要读/写扇区的时间)和**`传输时间`**三部分构成
   因为寻道和找扇区的距离远近不一，所以**`寻道时间和旋转延迟时间通常取平均值`**(平均寻道时间取**`从最外道移动到最内道时间的一半`**，平均旋转延迟时间**`取旋转半周的时间`**)

4. **数据传输速率**。磁盘存储器**`在单位时间内向主机传送数据的字节数`**，称为数据传输速率
   假设磁盘转数为`r转/秒`，每条磁道容量为`N字节`，则数据传输速率为 **D~r~ = r x N**

- **磁盘地址**

主机向磁盘控制器发送寻址信息，磁盘的地址一般如下所示

![image-20240626213248939](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240626213248939.png)

若磁盘有 16个盘面，每个盘面有 256个磁道，每个磁道划分为16 个扇区，则每个扇区地址要16位二进制代码，其格式如下所示

![image-20240626213341902](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240626213341902.png)

- **磁盘的工作过程**

磁盘的主要操作是**`寻址、读盘、写盘`**

每个操作都对应一个控制字，磁盘工作时，第一步是取控制字，第二步是执行控制字

磁盘属于机械式部件，其**`读/写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据`**

#### 磁盘列阵

**RAID(独立冗余磁盘阵列)**是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有**`更好的存储性能、可靠性和安全性`**

1. RAID0：无冗余和无校验的磁盘阵列
2. RAID1：镜像磁盘阵列
3. RAID2：采用纠错的海明码的磁盘阵列
4. RAID3：位交叉奇偶校验的磁盘阵列
5. RAID4：块交叉奇偶校验的磁盘阵列
6. RAID5：无独立校验的奇偶校验磁盘阵列

RAID0把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读/写，即条带化技术，这样不仅**`扩大了存储容量`**，还**`提高了磁盘存取速度`**，但**`RAID0没有容错能力`**

为了提高可靠性，RAID1使两个磁盘同时进行读/写，互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半

总之，RAID**`通过同时使用多个磁盘，提高了传输速率:通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量`**；**`通过镜像功能，提高安全可靠性;通过数据校验，提供容错能力`**

#### 固态硬盘

- **固态硬盘的特性**

固态硬盘(SSD)是一种**`基于闪存技术的存储器`**。它与U盘并无本质差别，只是容量更大存取性能更好

一个SSD**`由一个或多个闪存芯片和闪存翻译层组成`**，如下所示

![image-20240628211356071](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240628211356071.png)

闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译层将来自CPU的逻辑块读写请求翻译成对底层物理设备的读/写控制信号，因此，这个闪存翻译层相当于代替了磁盘控制器的角色

一个闪存由B块组成，每块由户页组成。通常，页的大小是512B ~ 4KB，每块由32 ~ 128页组成，块的大小为16KB ~ 512KB

**`数据是以页为单位读/写`**的，只有**`在一页所有的块整个被擦除后，才能写这一页`**
一旦一个块被擦除，块中的每个页就都可以直接再写一次。某个块进行了若干次重复写之后，就会磨损坏，不能再使用

**`随机写很慢`**，有两个原因：

1. 首先，擦除块较慢，通常比访问页高一个数量级
2. 其次，若写操作试图修改一个包含已有数据的页 P~i~ 则这个块中所有含有用数据的页都必须被复制到一个新(擦除过的)块中，然后才能进行对页 P~i~ 的写操作

比起传统磁盘，SSD有很多优点，它由半导体存储器构成，没有移动的部件，因而随机访问时间比机械磁盘要快很多，也没有任何机械噪声和振动，能耗更低，抗震性好，安全性高等

- **磨损均衡**

固态硬盘也有缺点，闪存的擦写寿命是有限的，一般是几百次到几千次

若直接用普通闪存组装SSD，则实际的寿命表现可能非常令人失望：读/写数据时会集中在SSD的一部分闪存，这部分闪存的寿命会损耗得特别快。一旦这部分闪存损坏，整块SSD也就损坏了

为了弥补 SSD的寿命缺陷，引入了磨损均衡。SSD损均衡技术大致分为两种：

1. 动态磨损均衡。**`写入数据时，自动选择较新的闪存块`**。老的闪存块先歇一歇
2. 静态磨损均衡。没有数据写入，**`SSD也会监测并自动进行数据分配`**，让老的闪存块承担无须写数据的存储任务，同时让较新的闪存块腾出空间，平常的读/写操作在较新的闪存块中进行。这样各个闪存块的寿命损耗就都差不多

---

提醒：

```
1、一个盘面对应一个磁头，即盘面好和磁头号是同一个概念
```

## 高速缓冲存储器

由于程序的转移概率不会很低，数据分布的离散性较大，因此单纯依靠并行主存系统提高主存系统的效率是有限的。高速缓存Cache拥有比主存更快的速度，因此**`在CPU和主存之间设置Cache可以显著提高存储系统的效率`**。**`Cache由SRAM组成，通常直接集成在CPU中`**

### 程序访问的局部性原理

程序访问的局部性原理包括**`时间局部性和空间局部性`**

- **时间局部性**：最近的未来要用到的信息，很可能**`是现在正在使用的信息`**，因为程序中存在循环和需要多次重复执行的子程序段，以及对数组的存储和访问操作
- **空间局部性**：最近的未来要用到的信息，很可能**`与现在正在使用的信息在存储空间上是邻近的`**，因此指令通常是顺序存储、顺序执行的，数据一般也是以向量、数组等形式簇聚的存储的

高速缓冲技术就是利用局部性原理，把程序中正在使用的部分数据存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行，从而提高程序的执行速度

### Cache的基本工作原理

为便于Cache与主存交换信息，Cache和主存都被划分为大小相等的块，Cache块也称Cache行，每行由若干字节组成，块的长度称为块长(也称行长)

因为Cahce中的块数要远少于主存中的块数，**`Cache中仅保存主存中最活跃的若干块的副本`**
因此，可按照某种策略预测CPU在未来一段时间内欲访存的数据，将其装入Cache

```
Cache块与主存块的大小相等，且Cache与主存之间是以块为单位来进行传输的
```

- 当CPU发出读请求时
  若**访存地址在Cache中命中**，就将此地址**`转换成Cache地址，直接对Cache进行读操作`**，与主存无关
  若**Cache不命中**，则**`仍需访问主存，并把此字所在的块一次性地从主存调入Cache`**
  若此时**Cache已满**，则需**`根据某种替换算法`**，用这个块**`替换Cache中原单位`**，而**`Cache与主存之间的数据交换则以Cache块为单位`**

- 当CPU发出写请求时
  若**Cache命中**，有可能会遇到Cache与主存中的内容不一致的问题，此时需要按照一定的写策略处理，常规的处理方法有**`全写法和回写法`**

注：`某些计算机中也采用同时访问Cache和主存的方式，若Cache命中，则终止访存`

根据Cache的读、写流程，可知实现Cache时需解决以下关键问题：

1. 数据查找。如何快速判断数据是否在Cache中
2. 地址映射。主存块如何存放在Cache中，如何将主存地址转换为Cache地址
3. 替换策略。Cache满后，使用何种策略对Cache块进行替换或淘汰
4. 写入策略。如何既保证主存块和Cache块的数据一致性，又尽量提升效率

### Cache命中率的计算

CPU欲访问的信息已在Cache中的比率称为Cache的命中率

设一个程序执行期间，`Cache的总命中次数`为 **N~c~** ，`访问主存的总次数`为 **N~m~** ，则`命中率` **H** 为：
$$
H = Nc~/~(Nc + Nm)
$$
为了提高访问效率，命中率H应当越接近1越好

设 **t~c~** 为`命中时的Cache访问时间`， **t~m~** 为`未命中时的访问时间`，**1-H** 表示`未命中率`，则Cache - 主存系统的`平均访问时间`为 **T~a~**：
$$
Ta = H*tc + (1-H)tm
$$

```
用简单的话来说就是：CPU先访问Cache，若Cache未命中再去访问主存

当然，前面说过有的计算机是可以同时访问Cache和主存的，这时CPU同时访问Cache和主存，因为Cache访问速度快，若在Cache中先找到了所要的数据，则立即停止对主存的访问；若先在主存中找到，即出现Cache未命中的情况
这时，总共花费时间：
Ta = H * tc + (1-H)tm
```

### Cache和主存的映射方式

由于Cache行数比主存块数少得多，因此**`主存中只有一部分块的信息可放在Cache中`**，因此**`在Cache中要为每块加一个标记位，指明它是主存中哪一块的副本`**
标记的内容相当于主存中块的编号。为了说明Cache行中的信息是否有效，每个Cache行需要一个有效位

Cache行中的信息是主存中某块的副本，**地址映射**是指**`把主存地址空间映射到Cache地址空间`**，即把存放在主存中的信息按照某种规则装入Cache

地址映射的方法有以下3种：

- **直接映射**

**`主存中的每一块只能装入Cache中的唯一位置`**

Cache的**`每行都有一位有效位`**，用来**`说明此行是否已被占用`**。但**`有效位不包含在Cache行地址结构中`**
Cache的**`每行都有与主存块号位相同位数的标记位`**，用来**`指出该行来自主存的哪一块`**

直接映射的地址结构为：

![image-20240702200456466](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240702200456466.png)

对于直接映射，有固定的映射规则：
$$
Cache行号 = 主存块号~mod~Cache总行数
$$

1. 若Cache中的某个位置**`没有内容`**，则**`直接写入`**，将**`有效位置1`**，并**`设置标记`**，**`同时将该地址中的内容送CPU`**
2. 若这个位置**`已有内容`**，则**`产生块冲突`**，原来的块将**`无条件地被替换`**出去，同时**`将新来的块送CPU`**


直接映射**`实现简单`**，但**`不够灵活`**，即使Cache的其他许多地址空着也不能占用，这使得直接映射的**`块冲突概率最高，空间利用率最低`**

![image-20240702211852880](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240702211852880.png)

由于直接映射的存放是有规律的，上图所示主存中块号为0、8、16等块其块号末尾3位都为0，即2^3^ = 8(Cache块数)，以此类推：

**若Cache总块数 = 2^n^，则主存块号末尾n位直接反映它在Cache中的位置**

- **全相联映射**

**`主存中的每一块可以装入Cache中的任何位置`**

Cache的**`每行都有一位有效位`**，用来**`说明此行是否已被占用`**。但**`有效位不包含在Cache行地址结构中`**
Cache的**`每行都有与主存块号位相同位数的标记位`**，用来**`指出该行来自主存的哪一块`**，因此**`CPU访存时需要与所有Cache行的标记进行比较`**

全相联映射的地址结构如下所示，行长一般指的是块内地址，剩下的位数都是标记位

![image-20240702200828211](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240702200828211.png)

CPU访问过程如下：

1. 将**`主存地址的高位标记与Cache各行的标记进行比较`**
2. 若有**`标记匹配且对应有效位为1`**，则**`命中`**，此时**`根据块内地址从该Cache行中取出信息`**
3. 若Cache行**`标记都不匹配`**，则**`不命中`**，此时**`CPU从主存中读取出该地址所在的一块信息送到Cache的任意一个空闲行中`**，**`将有效位置1`**，并**`设置标记`**，**`同时将该地址中的内容送CPU`**

优点：Cache块的**`冲突概率低`**，只要有空闲Cache行，就不会发生冲突；**`空间利用率高`**；**`命中率高`**
缺点：**`标记的比较速度较慢`**；实现成本较高，通常采用按内容寻址的相联存储器

![image-20240702210342343](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240702210342343.png)

每行的标记用于指出该行来自主存的哪一块，因此CPU访存时，通常为每个Cache行都设置一个比较器，比较器位数等于标记字段的位数访存时根据标记字段的内容来访问Cache行中的主存块，因为其查找过程是一种按内容访问的存取方式，所以是一种相联存储器
这种方式的时间开销和硬件开销都较大，不适合大容量Cache

- **组相连映射**

**`将Cache分成Q个大小相等的组，每个主存块可以装入固定组中的任意一行`**，即**`组间采用直接映射`**、而**`组内采用全相联映射的方式`**

一个组内有多少块即为多少路组相联映射，如2块为一组，则为2路组相联映射



组相联映射的地址结构为：

![image-20240702201826634](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240702201826634.png)

对于组相联映射，有固定的映射规则：
$$
Cache组号 = 主存块号~mod~Cache组数(Q)
$$
CPU访存的过程如下：

1. 根据访存地址中间的组好找到对应的Cache组
2. 将对应Cache组中每个行的标记与主存地址的高位标记进行比较
3. 若有一个相等且有效位为1，则访问Cache命中，此时根据主存地址中的块内地址，在对应Cache行中存取信息
4. 若都不相等或虽相等但有效位为0，则不命中，此时CPU从主存中读出该地址所在的一块信息送到对应Cache组的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送CPU

![image-20240702214105224](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240702214105224.png)

对直接映射和全相联映射的一种折中
当**`Q = 1`**时变为**`全相联映射`**；当**`Q = Cache行数`**时变为**`直接映射`**

路数越大，即每组Cache行的数量越大，发生块中去的概率越低，但相联比较电路也越复杂
选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射

```
直接映射因为每块只能映射到唯一的Cache行，因此只需设置1个比较器
而r路组相连映射需要在对应分组中与r个Cache行进行比较，因此需设置r个比较器
```

---

三种映射方式中，直接映射的每个主存块只能映射到Cache中的某一固定行；全相联映射可以映射到所有Cache行；N路相连映射可以映射到N行。当Cache大小、主存块大小一定时：

1. 直接映射的命中率最低，全相联映射的命中率最高
2. 直接映射的判断开销最小、所需时间最短，全相联映射的判断开销最大、所需时间最长
3. 直接映射标记所占的额外空间开销最少，全相联映射所占的额外空间开销最大

### Cache中主存块的替换算法

采用全相联映射或组相联映射方式时，从主存向Cache传送一个新块，当Cache或Cache组中的空间已被占满时，就需要使用替换算法置换Cache行
而采用直接映射时，一个给定的主存块只能放到唯一的固定Cache行中，所以在对应Cache行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，因而无需考虑替换算法

常用的替换算法有：**`随机(RAND)算法`**、**`先进先出(FIFO)算法`**、**`近期最少使用(LRU)算法`**、**`最不经常使用(LFU)算法`**

- **随机算法**：**`随机地确定替换的Cache行`**
  实现比较简单，但**`未依据程序访问的局部性原理`**，因此可能命中率较低
- **先进先出算法**：**`选择最早调入的Cache行进行替换`**
  比较容易实现，但也**`未依据程序访问的局部性原理`**，因为最早进入的主存块也可能时目前经常要用的
- **近期最少使用算法**：依据程序访问的局部性原理，**`选择近期内长久未访问过的Cache行进行替换`**
  其平均命中率要比FIFO的高，是**`堆栈类算法`**
  为每一个Cache块设置一个计数器，用于**`记录每个Cache块已经有多久没被访问了`**了
  当**`Cache满后，替换计数器数值最大的`**

**`命中`**时，所命中的行的计数器**`清零`**，**`比其低的计数器加1`**，其余不变
**`未命中`**且还**`有空闲行`**时，**`新装入的行的计数器置0，其余非空闲行全加1`**
**`未命中`**且**`无空闲行`**时，**`计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1`**

近期最少使用算法(LRU)算法，**`基于局部性原理`**，近期被访问过的主存块在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的

LRU算法的实际运行效果优秀，Cache命中率高
但若**`频繁访问的主存块数量 > Cache行的数量`**，则有可能发生**`抖动现象`**

- **最不经常使用算法**：**`将一段时间内被访问次数最少的Cache行换出`**
  每行设置一个计数器，新行装入后从0开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，**`将计数值最小的行换出`**

### Cache的一致性问题

因为Cache中的内容是主存块副本，相当于主存一部分的复制体，而当CPU的写操作是针对与Cache块时，这时Cache块中的数据发生改变，而原来主存中对应的位置是没有发生改变的。因此当对Cache中的内容进行更新时，需要选用写操作策略使Cache内容和主存内容保持一致

#### Cache写操作命中

有两种处理方法：

- **全写法**

当CPU对Cache写命中时，必须把数据同时写入Cache和主存。当某一块需要替换时，就不必把这一块写回主存了，用新调入的块直接覆盖即可

优点：方法实现简单，**`能随时保持主存数据的正确性`**
缺点：**`增加了访存次数，降低了Cache效率`**

写缓冲：为减少全写法直接写入主存的时间损耗，在Cache和主存之间加一个写缓冲，如下所示：

![image-20240703210434885](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240703210434885.png)

**`CPU同时写数据到Cache和写缓冲中，写缓冲再将内容写入主存`**
写缓冲是一个FIFO队列，写缓冲可以解决速度不匹配的问题，但若频繁出现写时，会使写缓冲饱和溢出

- **回写法**

当CPU对Cache写命中时，只把数据写入Cache，而不立即写入主存，只有当此块被替换出时才写回主存

这种方法减少了访存次数，但**`存在数据不一致的隐患`**

为了减少写回主存的次数，**`给每个Cache行设置一个修改位(脏位)`**：

若**`修改位为1`**，则说明对应**`Cache行中的块被修改过`**，**`替换时须写回主存`**
若**`修改位为0`**，则说明对应**`Cache行中的块未被修改过`**，**`替换时无须写回主存`**

#### Cache写操作不命中

全写法和会写法都对应与Cache写命中(要被修改的块在Cache中)时的情况，对于Cache写草错不命中也有两种处理方法：

- **写分配法**：当CPU对Cache**`写不命中`**时，**`把主存中的块调入Cache，在Cache中修改`**。通常搭配回写法使用
- **非写分配法**：当CPU对Cache** **时，**`只写入主存，不调入Cache`**。通常搭配全写法使用

---

多级Cache结构

![image-20240703212244078](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240703212244078.png)

**`离CPU越近的速度越快，容量越小`**
**`离CPU越远的速度越慢，容量越大`**

当然在各级Cache中同样会存在数据不一致的问题
因此**`各级Cache之间`**通常采用**`全写法+非写分配法`**；**`Cache和主存之间`**通常采用**`回写法+写分配法`**

---

提醒：

```
1、
写分配法：在写不命中时，加载相应的第一层中的块到高速缓存(Cache)中，然后更新这个高速缓存块
非写分配法：避开Cache，直接把这个字写到主存中
两种方法都是在不命中Cache的情况下(失效时)使用的，而回写法和全写法是在命中Cache的情况下使用的
2、在写Cache时，写分配法和回写法搭配使用，非写分配法和全写法搭配使用
3、写分配法、非写分配法、全写法、回写法这些都是基于写操作
4、时间局部性是指一个内存位置被重复引用，如常量等可以被重复利用的值；空闲局部性是指若一个内存位置被引用，则它附近的位置很快也会被引用，如指令、向量、数组等
5、指令Cache通常比数据Cache具有更好的空间局部性，这是因为指令流通常是顺序执行的，而数据流跳转或随机访问的概率较高
6、由于空间局部性，同一主存块中的数据的访问概率较高，因此增加Cache块会提高命中率
7、当CPU访存时，是直接根据主存物理地址进行访问的，而不是高速缓存地址，说到底，Cache中也是主存物理地址的副本
```

## 页式存储器

一个**`程序(进程)`**在逻辑上**`被分为若干个大小相等的页面`**
**`页面大小与块的大小相同`**。每个**`页面可以离散地存放入不同的主存块中`**

![image-20240708202326693](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240708202326693.png)

如上图右所示。4KB的程序被分为4个页，每个页面的大小和物理块的大小相同，各个页被零散的分布在主存的各个不同位置中

### 虚地址与实地址

**虚地址**：即**逻辑地址**，是程序员视角看到的地址
**实地址**：即**物理地址**，是实际在主存中的地址

![image-20240708203945214](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240708203945214.png)

**`在主存中会长久的保留一张页表`**，其**`记录了每个逻辑页面存放在哪个主存块中`**，即**`建立了逻辑页号与主存块号的映射关系`**
每一对逻辑页号与主存块号之间的映射关系被称为**页表项**

**`CPU`**执行的机器指令中，**`使用的是逻辑地址`**，因此需要通过页表将逻辑地址转化为物理地址

**页表基址寄存器**：指明了**`页表在主存中的存放地址`**。因为页表是常驻主存的因此需要一个寄存器来记录页表的位置

### 快表(TLB)

依据程序访问的**`局部性原理`**，在一段时间内总是经常访问某些页时，将这些页表项放入更高速的存储器，即可加快地址转换的速度

这个更高速的存储器即类似于Cache的结构：**快表(TLB)**
相应地**`把放在主存中的页表`**称为**慢表(Page)**

**`在地址转换时，首先查找快表，若命中，则无须访问存放在主存中的慢表`**

注：`快表中存储的是页表项的副本；Cache中存储的是主存块的副本`

快表与慢表的区别：

```
快表由SRAM实现；而慢表由DRAM实现
快表的容量比慢表小得多：快表中存放的是慢表页表项的副本

另外，快表是一种相联存储器，可以按内容来寻访
```

因为快表的容量比慢表小，因此一定会存在替换的问题，其工作原理类似于Cache，**`通常采用全相联或组相联映射方式`**
TLB表项由页表表项内容和TLB标记组成

**全相联映射**下，TLB标记就是对应页表项的逻辑页号
**组相联方式**下，TLB标记则是对应逻辑页号的高位部分，而逻辑页号的低位部分作为TLB组的组号

## 虚拟存储器

**`主存和辅存共同构成了虚拟存储器`**，二者**`在硬件和系统软件的共同管理下工作`**
对于程序员而言，虚拟存储器是透明的。虚拟存储器**`具有主存的速度和辅存的容量`**

### 虚拟存储器的基本概念

虚拟存储器**`将主存和辅存的地址空间统一编址`**，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置

CPU使用虚地址时：

1. 先判断这个虚地址对应的内容是否已装入主存
2. 若**`已在主存`**中，则**`通过地址变换`**，**`CPU可直接访问主存指示的实际单元`**
3. 若**`不在主存`**中，则**`把包含这个字的一页或一段调入主存后再由CPU方访问`**
4. 若**`主存已满`**，则**`采用替换算法置换主存中的交换块(页面)`**

虚拟存储器类似于Cache，**`将辅存中经常访问的数据副本存放到主存中`**，但是**`缺页(或段)而访问辅存的代价很大`**，提高命中率是关键
因此虚拟存储机制采用**`全相联映射`**，每个虚页面可以存放到对应主存区域的任何一个空闲页位置
此外，当进行写操作时，不能每次写操作都同时写回磁盘，因而，在处理一致性问题时，采用**`回写法`**

### 页式虚拟存储器

页式虚拟存储器**`以页为基本单位`**，主存空间和虚拟地址空间都**`被划分成相同大小的页`**

主存空间中的页称为**物理页、实页、页框**
虚地址空间中的页称为**虚拟页、虚页**

#### 页表

不同于页式存储器的页表的是，页式虚拟存储器中增加了一些有意义的比特位

- **有效位**也称**装入位**，用来**`表示对应页面是否在主存`**
  若为**`1`**，则**`表示该虚拟页已从外存调入主存`**，此时**`页表项存放该页的物理页号`**
  若为**`0`**，则**`表示没有调入主存`**，此时**`页表项可以存放该页的磁盘地址`**
- **脏位**也称**修改位**，用来**`表示页面是否被修改过`**
  **`虚存机制中采用回写策略`**，利用脏位**`可判断替换时是否需要写回磁盘`**
- **引用位**也称**使用位**，**`用来配合替换策略进行设置`**
  如是否实现最先调入(FIFO位)或最近最少用(LRU位)策略等

![image-20240708211920884](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240708211920884.png)

以下图页表为例：

![image-20240705210714837](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240705210714837.png)

1. 假设CPU欲访问的数据在第1页，对应的有效位为1
   说明该页已存放在主存中，再通过地址转换部件将虚拟地址转换为物理地址，然后到相应的主存实页中存取数据
2. 假设CPU欲访问的数据在第5页，对应的有效位为0
   发生缺页异常，需调用操作系统的缺页异常处理程序
   缺页处理程序根据对应表项中的存放位置字段，将所缺页面从磁盘调入一个空闲的物理页框
   若主存中没有空闲页框，还需要选择一个页面替换
   由于采用回写策略，因此换出页面时根据脏位确定是否要写回磁盘
   缺页处理过程中需要对页表进行相应的更新

优点：**`页面的长度固定，页表简单，调入方便`**
缺点：程序不可能正好是页面的整数倍，**`最后一页的零头将无法利用而造成浪费`**，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便

#### 地址转换

虚拟存储系统中，指令给出的地址是虚拟地址，因此**`当CPU执行指令时，要先将虚拟地址转换为主存物理地址，才能到主存中存取指令和数据`**

1. **`每个进程都有一个页表基地址寄存器`**，存放该进程的页表首地址，据此找到对应的页表首地址
2. 然后根据虚拟地址高位的虚拟页号找到对应的页表项
3. 若**`有效位为1`**，则**`取出物理页号，和虚拟地址低位的页内地址拼接，形成实际物理地址`**
4. 若**`有效位为0`**，说明**`缺页`**，需要操作系统进行缺页处理

访存时先访问一次主存去查页表，再访问主存才能取得数据
若缺页，则还要进行页面替换、页面修改等，因此采用虚拟存储机制后，访问主存的次数更多了

#### 具有TLB和Cache的多级存储系统

1. TLB采用**`全相联方式`**，每一项都有一个比较器，查找时将虚页号与每个TLB标记字段同时进行比较
   若**`有某一项相等且对应有效位为1，则TLB命中，此时可直接通过TLB进行地址转换`**
   若**`未命中`**，则**`TLB缺失`**，需要**`访问主存去查页表`**
2. 虚页号被分成页目录索引和页表索引两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB
   若TLB已满，则还需要采用替换策略
3. 完成由虚拟地址到物理地址的转换后，Cache机构根据映射方式将物理地址划分成多个字段
   然后根据映射规则找到对应的Cache行或组，将对应Cache行中的标记与物理地址中的高位部分进行比较
   若相等且对应有效位为1，则Cache命中，此时根据块内地址取出对应的字送给CPU

查找时，**`快表和慢表也可以同步进行`**，若快表中有此虚页号，则能很快地找到对应的实页号，并且使慢表的查找作废，从而就能做到虽采用虚拟存储器但访问主存速度几乎没有下降

在一个具有TLB和Cache的多级存储系统中，CPU一次访存操作可能涉及TLB、页表、Cache、主存和磁盘的访问

CPU访存过程中存在三种缺失情况：

1. **TLB缺失**：要访问的页面的页表项不在TLB中
2. **Cache缺失**：要访问的主存块不在Cache中
3. **Page缺失**：要访问的页面不在主存中

由于TLB只是页表的一部分副本，因此**`Page缺失时，TLB也必然缺失`**
同理，Cache也只是主存的一部分副本，页表未命中意味着信息不在主存，因此**`Page缺失时，Cache也必然缺失`**

![image-20240705214247816](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240705214247816.png)

1. 第一种组合，此时无需访问主存
2. 第二种和第三种组合都需要访问一次主存
3. 第四种组合需要访问两次主存
4. 第五种组合发生缺页异常，需要访问磁盘，并且至少访问两次主存

Cache缺失处理由硬件完成
缺页处理由软件完成，操作系统通过缺页异常处理程序来实现
TLB缺失既可以用硬件，又可以用软件来处理

### 段式虚拟存储器

段式虚拟存储器中的**`段是按程序的逻辑结构划分的`**，**`各个段的长度因程序而异`**
把虚拟地址分为两部分：**`段号和段内地址`**

虚拟地址到实地址之间的变换是由**`段表`**来实现的

段表是**`程序的逻辑段和在主存中存放位置的对照表`**
段表的每行记录**`与某个段对应的段号、装入位、段起点和段长等信息`**
**`因为段的长度可变`**，所以**`段表中要给出各段的起始地址与段的长度`**

CPU根据虚拟地址访存时：

1. 首先根据段表基地址与段号拼接成对应的段表项
2. 然后根据该段表项的装入位判断该段是否已调入主存
   装入位为1，表示该段已调入主存
   装入位为0，表示该段不在主存中
3. 已调入主存时，从段表读出该段在主存中的起始地址，与段内地址(偏移量)相加，得到对应的主存实地址

因为段本身是程序的逻辑结构所决定的一些独立部分，因而**`分段对程序员来说是不透明的`**
而分页对程序员来说是透明的，程序员编写程序时不需知道程序将如何分页

优点：**`段的分界与程序的自然分界相对应`**，因而**`具有逻辑独立性`**，使得它**`易于编译、管理、修改和保护`**，也**`便于多道程序的共享`**
缺点：是因为段长度可变，**`分配空间不容易在段间留下碎片，不好利用，造成浪费`**

### 段页式虚拟存储器

在段页式虚拟存储器中，**`把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页`**，程序对主存的调入、调出仍**`以页为基本交换单位`**

**`每个程序对应一个段表，每段对应一个页表`**
**`段的长度必须是页长的整数倍，段的起点必须是某一页的起点`**

虚地址分为**`段号、段内页号、页内地址`**三部分

CPU根据虚地址访存时：

1. 首先根据段号得到段表地址
2. 然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址
3. 最后从页表中取出实页号，与页内地址拼接形成主存实地址

优点：兼具页式和段式虚拟存储器的优点，**`可以按段实现共享和保护`**
缺点：在地址变换过程中需要两次查表，系统**`开销较大`**

### 虚拟存储器与Cache的比较

虚拟存储器与Cache的相同之处：

1. 最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度
2. 都把数据划分为小信息块，并作为基本的交换单位，虚存系统的信息块更大
3. 都有地址映射、替换算法、更新策略等问题
4. 都依据局部性原理应用“快速缓存”的思想，将活跃的数据放在相对高速的部件中

虚拟存储器与Cache的不同之处：

1. **`Cache主要解决系统速度`**
   **`虚拟存储器是为了解决主存容量`**
2. **`Cache全由硬件实现`**，是硬件存储器，对所有程序员透明
   **`虚拟存储器由OS和硬件共同实现`**，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明
3. 对于不命中性能影响，因为CPU的速度约为Cache的10倍，主存的速度为硬盘的100倍以上，因此**`虚拟存储器系统不命中时对系统性能影响更大`**
4. **`CPU与Cache和主存都建立了直接访问的通路`**，而**`辅存与CPU没有直接通路`**
   Cache不命中时主存能和CPU直接通信，同时将数据调入Cache
   虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信

---

提醒：

```
1、局部性原理的含义是在一个程序的执行过程中，其大部分情况下是顺序执行的
时间局部性：某条指令或数据使用后，在最近一段时间内有较大的可能再次被访问
空间局部性：某条指令或数据使用后，其邻近的指令或数据可能在近期被使用
在虚拟存储管理系统中，程序只能访问主存获得指令和数据
在程序的执行过程中，程序对主存的访问是不均匀的
2、虚拟存储器中，地址映射由操作系统完成，但需要一部分硬件基础的支持
3、Cache不命中时从主存读取数据，页表不命中时从辅存读取数据
4、Cache缺失处理由硬件完成，TLB缺失处理既可以由硬件完成，又可以由软件完成
5、虚拟存储器的实际容量小于或等于主存和辅存的容量之和
6、快表采用高速相联存储器，它的速度快来源于硬件本身，而不是依赖搜索算法来查找的；慢表存储在内存中，通常是依赖于查找算法来查找的
7、快表与慢表的命中率没有必然的联系，快表仅是慢表的一个部分拷贝，不能得到比慢表更多的结果
```

## 本章小结

`存储器系统为何要分这些层次?计算机如何管理这些层次?`

```
Cache-主存层在存储系统中主要CPU访存起加速作用
即从整体运行的效果看，CPU访存速度加快，接近于Cache 的速度，而寻址空间和位价却接近于主存
主存-辅存层在存储系统中主要起扩容作用
即从程序员的角度看，他所使用的存储器的容量和位价接近于辅存，而速度接近于主存
因此从整个存储系统来看，就达到了速度快、容量大、位价低的效果

主存与Cache之间的信息调度全部由硬件自动完成
而主存与辅存的信息调度则采用虚拟存储技术实现，即将主存与辅存的一部分通过软/硬结合的技术组成虚拟存储器，程序员可用这个比
主存实际空间(物理地址空间)大得多的虚拟地址空间(逻辑地址空间)编程，当程序运行时，再由软/硬件自动配合完成虚拟地址空间与主存实际物理空间的转换
```

`影响Cache性能的因素有哪些?`

```
决定Cache系统访存效率重要因素是命中率
1、命中率与映射方式有关，全相联映射方式的命中率最高，直接映射方式的命中率最低
2、命中率与Cache容量有关，显然Cache容量越大，命中率就越高
3、命中率还与主存块(或Cache行)的大小有关，主存块的大小要适中

除上述因素外
系统是采用单级还是采用多级Cache
数据Cache和指令Cache是分离还是合在一起
主存-总线-Cache-CPU之间采用什么架构等
都会影响Cache的总体性能
```

`虚拟存储系统的页面是设置得大一些好还是设置得小一些好?`

```
面大小要适中
页面太小时，平均页内剩余空间较小，可节省存储空间，但会使得页表增大，页面太小时也不能充分利用空间局部性来提高命中率
页面太大时，可减少页表空间，但平均页内剩余空间较大，会浪费较多存储空间，页面太大还会使页面调入/调出的时间较长
```

`Cache 行的大小和命中率之间有什么关系?`

```
Cache行的长度较大时，能充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到Cach 中，因而可以增加命中机会

但是，行长也不能太大，主要原因有两个:
1、行长大使失效损失变大。也就是说，若未命中，则需花更多时间从主存读块
2、行长太大，Cache 项数变少，因而命中的可能性变小

Cache行的长度较小时，命中率会很低，但好处是存取块的代价较小
```

`发生取指令Cache 缺失的处理过程是什么?`

```
1、程序计数器恢复当前指令的值
2、对主存进行读的操作
3、将读入的指令写入Cache中，更改有效位和标记位
4、重新执行当前指令
```

`Cache总容量与映射方式有何种关系?`

```
Cache总容量 = [每个Cache行标记项的容量(有效位、脏位、LRU 替换位、标记位) + Cache行长] x Cache总行数

有效位和标记位是所有Cache所必需的
脏位只在Cache采用回写法时才需要设置
LRU替换位只在Cache采用LRU替换算法时才需要设置

有效位：占1位，用于说明Cache行中的数据是否有效
脏位(修改位)：占1位，回写法才需要设置，用以说明Cache行中的数据是否被修改过
LRU替换位：位数为log2(组内块数)，用于LRU替换算法中的访问计数
标记位Tag：主存地址结构中的标记字段，其位数取决于所用的映射方式，用于匹配Cache行对应主存中的哪个块
```

![image-20240705220211354](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240705220211354.png)
