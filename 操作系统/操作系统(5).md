# 输入/输出(I/O)管理

**考纲内容**

- I/O管理基础
  设备：设备的基本概念，设备的分类，I/O接口
  I/O控制方式：轮询方式，中断方式，DMA方式
  I/O软件层次结构：中断处理程序，驱动程序，设备独立性软件，用户层I/O软件
  输入/输出应用程序接口：字符设备接口，块设备接口，网络设备接口，阻塞/非阻塞I/O
- 设备独立软件
  缓冲区管理：设备分配与回收；假脱机技术(SPOOLing)；设备驱动程序接口
- 外存管理
  磁盘：磁盘结构，格式化，分区，磁盘调度算法
  固态硬盘：读/写性能特效，磨损均衡

**复习提示**

重点掌握I/O接口、I/O软件、三种I/O控制方式、高速缓存与缓冲区、SPOOLing技术，磁盘特性和调度算法。本章很多知识点与硬件高度相关

## I/O管理概述

### I/O设备

**1、设备的分类**

I/O设备是指**`可以将数据输入计算机的外部设备`**，或者**`可以接收计算机输出数据的外部设备`**

I/O设备的类型繁多，从不同的⻆度可将它们分为不同的类型：

**按`信息交换的单位`分类**

I/O设备可分为：

1. **块设备**。信息交换以**`数据块`**为单位，如磁盘、磁带等
   磁盘设备的基本特征是**`传输速率较高、可寻址`**，即对它**`可随机地读/写任意一块`**
2. **字符设备**。信息交换以**`字符`**为单位，如交互式终端机、打印机等
   它们的基本特征是**`传输速率低、不可寻址`**，并且**`时常采用中断I/O方式`**

**按`设备的传输速率`分类**

I/O设备可分为：

1. 低速设备。传输速率仅为每秒几字节到数百字节，如键盘、鼠标等
2. 中速设备。传输速率为每秒数千字节至数万字节，如激光打印机等
3. 高速设备。传输速率在数百千字节至千兆字节，如磁盘机、光盘机等

**按`设备的使用特性`分类**

I/O设备可分为：

1. **存储设备**。**`用于存储信息的外部设备`**，如磁盘、磁带、光盘等
2. **输入/输出设备**。又可分为**`输入设备、输出设备和交互式设备`**
   输入设备用于向计算机输入外部信息，如键盘、鼠标、扫描仪等
   输出设备用于计算机向外输出数据信息，如打印机等
   交互式设备则集成了上述两类设备的功能，如触控显示器等

**按`设备的共享属性`分类**

I/O设备可分为：

1. **独占设备**。**`同一时刻只能由一个进程占用的设备同一时刻只能由一个进程占用的设备`**。一旦将这类设备分配给某进程，便由该进程独占，直至用完释放。低速设备一般是独占设备，如打印机
2. **共享设备**。**`同一时间段内允许多个进程同时访问的设备`**。对于共享设备，可同时分配给多个进程，通过分时的方式共享使用。典型的共享设备是磁盘
3. **虚拟设备**。通过**`SPOOLing技术`**将独占设备改造为共享设备，**`将一个物理设备变为多个逻辑设备`**，从而可将设备同时分配给多个进程

**2、I/O接口**

I/O接口(又称`设备控制器`)是**`CPU与设备之间的接口`**，以**`实现设备和计算机之间的数据交换`**

它接收发自CPU的命令，控制设备工作，使CPU能从繁杂的设备控制事务中解脱出来。设备控制器主要由三部分组成：

![image-20240423195724959](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240423195724959.png)

- 设备控制器与CPU的接口。用于**`实现CPU与设备控制器之间的通信`**
  该接口有三类信号线：数据线、地址线和控制线
  数据线传送的是**`读/写数据、控制信息和状态信息`**
  地址线传送的是**`要访问I/O接口中的寄存器编号`**
  控制线传送的是**`读/写等控制信号`**
- 设备控制器与设备的接口。一个设备控制器可以连接一个或多个设备，因此控制器中有一个或多个设备接口
  **`每个接口都可传输数据、控制和状态三种类型的信号`**
- I/O逻辑。用于**`实现对设备的控制`**。它通过一组控制线与CPU交互，对从CPU收到的I/O命令进行译码
  CPU启动设备时，将启动命令发送给控制器，同时通过地址线将地址发送给控制器，由控制器的I/O逻辑对地址进行译码，并对所选设备进行控制

设备控制器的主要功能有：

```
1、接收和识别命令，如磁盘控制器能接收CPU发来的读、写、查找等命令
2、数据交换，包括CPU和控制器之间的数据传输，以及控制器和设备之间的数据传输
3、标识和报告设备的状态，以供CPU处理
4、地址识别
5、数据缓冲
6、差错控制
```

**3、I/O接口的类型**

从不同的⻆度看，I/O接口可以分为不同的类型：

- 按**`数据传送方式`**(外设和接口一侧)，可分为**`并行接口`**(一个字节或者一个字的所有位同时传送)和**`串行接口`**(一位一位地有序传送)，接口要完成数据格式的转换
- 按**`主机访问I/O设备的控制方式`**，可分为**`程序查询接口`**、**`中断接口`**和**`DMA接口`**等
- 按**`功能选择的灵活性`**，可分为**`可编程接口`**(通过编程改变接口功能)和**`不可编程接口`**

**4、I/O端口**

I/O端口是指**`设备控制器中可被CPU直接访问的寄存器`**，主要有以下三类寄存器：

- **数据寄存器**：**`用于缓存从设备送来的输入数据`**，或**`从CPU送来的输出数据`**
- **状态寄存器**：**`保存设备的执行结果或状态信息`**，以**`供CPU读取`**
- **控制寄存器**：由CPU写入，**`以便启动命令或更改设备模式`**

I/O端口要想能够被CPU访问，就要**`对各个端口进行编址`**，每个端口对应一个端口地址。而对I/O端口的编址方式有与存储器**`独立编址`**和**`统一编址`**两种

![image-20240423200826889](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240423200826889.png)

- **独立编址**

独立编址是指**`为每个端口分配一个I/O端口号`**。**`I/O端口的地址空间与主存地址空间是两个独立的地址空间`**，它们的范围可以重叠，相同地址可能属于不同的地址空间

**`普通用户程序不能对端口进行访问`**，只有操作系统使用特殊的I/O指令才能访问端口

优点：I/O端口数比主存单元少得多，只需少量地址线，使得**`I/O端口译码简单，寻址速度更快`**。使用专用I/O指令，可使程序更加清晰，便于理解和检查
缺点：I/O指令少，**`只提供简单的传输操作`**，所以程序设计的**`灵活性较差`**。此外，CPU需要提供两组独立的存储器和设备的读/写控制信号，**`增加了控制的复杂性`**

- **统一编址**

统一编址又称`内存映射I/O`，是指**`将主存地址空间分出一部分给I/O端口进行编址`**，**`I/O端口和主存单元在同一地址空间的不同分段中`**，用统一的访存指令就可访问I/O端口

优点：不需要专⻔的I/O指令，使得CPU访问I/O的操作更加**`灵活和方便`**，还使得**`端口有较大的编址空间`**。I/O访问的**`保护机制可由虚拟存储管理系统来实现`**，无须专⻔设置
缺点：**`端口地址占用了部分主存地址空间，使主存的可用容量变小`**。此外，由于在识别I/O端口时全部地址线都需参加译码，使得译码电路更复杂，**`降低了寻址速度`**

### I/O控制方式

I/O控制是指**`控制设备和主机之间的数据传送`**

在I/O控制方式的发展过程中，始终贯穿着这样一个宗旨：尽量减少CPU对I/O控制的干预，将CPU从繁杂的I/O控制事务中解脱出来，以便其能更多地去执行运算任务。I/O控制方式共有4种：

**1、程序直接控制方式**

CPU对I/O设备的控制采取**`轮询的I/O方式`**，又称**`程序轮询方式`**

![image-20240423202530632](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240423202530632.png)

CPU向设备控制器发出一条I/O指令，启动从I/O设备读取一个字(节)，然后**`不断地循环测试设备状态`**(称为轮询)，**`直到确定该字(节)已在设备控制器的数据寄存器中`**
于是CPU将数据寄存器中的数据取出，送入内存的指定单元，这样便完成了一个字(节)的I/O操作

这种方式简单且易于实现
但由于在CPU中未采用中断机构，使I/O设备无法向CPU报告它已完成了一个字(节)的输入操作。因此CPU的绝大部分时间都处于等待I/O设备状态的循环测试中，**`CPU和I/O设备只能串行工作`**，由于**`CPU和I/O设备的速度差异很大`**，导致**`CPU的利用率相当低`**

**2、中断驱动方式**

中断驱动方式的思想是：**`允许I/O设备主动打断CPU的运行并请求服务，从而“解放”CPU`**，使得**`CPU向设备控制器发出一条I/O指令后可以继续做其他有用的工作`**

![image-20240423202955971](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240423202955971.png)

- 从**`设备控制器的⻆度`**来看：

设备控制器从CPU接收一个读命令，然后从设备读数据
一旦数据读入设备控制器的数据寄存器，便通过控制线给CPU发出中断信号，表示数据已准备好，然后等待CPU请求该数据
设备控制器收到CPU发出的取数据请求后，将数据放到数据总线上，传到CPU的寄存器中
至此，本次I/O操作完成，设备控制器又可开始下一次I/O操作

- 从**`CPU的⻆度`**来看：

当前运行进程发出读命令，该进程将被阻塞，然后保存该进程的上下文，转去执行其他程序
在每个指令周期的末尾，CPU检查中断信号。当有来自设备控制器的中断时，CPU保存当前运行进程的上下文，转去执行中断处理程序以处理该中断请求。这时，CPU从设备控制器读一个字的数据传送到寄存器，并存入主存
中断处理完后解除发出I/O命令的进程的阻塞状态，然后恢复该进程(或其他进程)的上下文，然后继续运行

---

相比于程序轮询I/O方式，在中断驱动I/O方式中，设备控制器通过中断主动向CPU报告I/O操作已完成，不再需要轮询，在设备准备数据期间，CPU和设备并行工作，CPU的利用率得到明显提升

但是，中断驱动方式仍有两个明显的问题：
1、设备与内存之间的数据交换都必须经过CPU中的寄存器
2、CPU是以字(节)为单位进行干预的，若将这种方式用于块设备的I/O操作，则显然是极其低效的

因此，中断驱动I/O方式的速度仍然受限

**3、DMA方式**

DMA(直接存储器存取)方式的基本思想是，**`在I/O设备和内存之间开辟直接的数据交换通路，彻底“解放”CPU`**

DMA方式的特点如下：

1. 基本传送单位是数据块，而不再是字(节)
2. 所传送的数据，是从设备直接送入内存的，或者相反，而不再经过CPU
3. 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预

DMA控制器的组成：

![image-20240423203808008](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240423203808008.png)

为了实现主机和控制器之间直接交换成块的数据，须在DMA控制器中设置如下4类寄存器：

1. **命令/状态寄存器(CR)**。接收从CPU发来的I/O命令、有关控制信息，或设备的状态
2. **内存地址寄存器(MAR)**。在输入时，它存放将数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址
3. **数据寄存器(DR)**。暂存从设备到内存或从内存到设备的数据
4. **数据计数器(DC)**。存放本次要传送的字(节)数

![image-20240423203956691](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240423203956691.png)

如上所示，DMA方式的工作过程是：

CPU接收到设备的DMA请求时，它向DMA控制器发出一条命令，同时设置MAR和DC初值，启动DMA控制器，然后继续其他工作
之后CPU就将I/O控制权交给DMA控制器，由DMA.控制器负责数据传送
DMA控制器直接与内存交互，每次传送一个字，这个过程不需要CPU参与
整个数据传送结束后，DMA控制器向CPU发送一个中断信号

因此**`只有在传送开始和结束时才需要CPU的参与`**

DMA方式的优点：数据传输**`以“块”为单位`**，**`CPU介入的频率进一步降低`**；数据传送不再经过CPU的寄存器，**`CPU和设备的并行操作程度得到了进一步提升`**

**4、通道控制方式**

I/O通道是一种特殊的处理机，它可执行一系列通道指令

设置通道后，CPU只需向通道发送一条I/O指令，指明通道程序在内存中的位置和要访问的I/O设备，通道收到该指令后，执行通道程序，完成规定的I/O任务后，向CPU发出中断请求

通道方式**`可以实现CPU、通道和I/O设备三者的并行工作`**，从而更有效地提高整个系统的资源利用率

```
通道与一般处理机的区别是：通道指令的类型单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说通道与CPU共享内存

通道与DMA方式的区别是：DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。另外，每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换
```

### I/O软件层次结构

I/O软件涉及的面很宽，**`往下与硬件有着密切关系，往上又与虚拟存储器系统、文件系统和用户直接交互`**，它们都需要I/O软件来实现I/O操作

为使复杂的I/O软件能具有清晰的结构、良好的可移植性和易适应性，目前普遍采用**`层次式结构`**的I/O软件。将系统中的设备管理模块分为若干层次，**`每层都是利用其下层提供的服务`**，完成输入/输出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务

在层次式结构的I/O软件中，**`只要层次间的接口不变，对某一层次中的软件的修改都不会引起其下层或高层代码的变更，仅最低层才涉及硬件的具体特性`**

一个比较合理的层次划分如下所示：

![image-20240424143657310](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240424143657310.png)

整个I/O软件可以视为具有4个层次的系统结构，各层次及其功能如下：

- **用户层软件**

**`实现与用户交互的接口`**，用户可直接调用在用户层提供的、与I/O操作有关的库函数，对设备进行操作
通常大部分的I/O软件都在操作系统内核，但仍有一小部分在用户层，包括与用户程序链接在一起的库函数
**`用户层I/O软件必须通过一组系统调用来获取操作系统服务`**

- **设备独立性软件**

用于**`实现用户程序与设备驱动器的统一接口、设备命名、设备保护以及设备的分配与释放等`**，同时**`为设备管理和数据传送提供必要的存储空间`**

`设备独立性`也称`设备无关性`，其含义是指**`应用程序所用的设备不局限于某个具体的物理设备`**
为实现设备独立性而引入了**`逻辑设备`**和**`物理设备`**这两个概念
**`在应用程序中，使用逻辑设备名来请求使用某类设备`**；**`而在系统实际执行时，必须将逻辑设备名映射成物理设备名`**

使用逻辑设备名的好处：

```
增加设备分配的灵活性
易于实现I/O重定向

所谓I/O重定向，是指用于I/O操作的设备可以更换(重定向)，而不必改变应用程序
```

为了实现设备独立性，必须再在驱动程序之上设置一层设备独立性软件，设备独立性软件的主要功能可分为以下两个方面：

1. **`执行所有设备的公有操作`**，包括：对设备的分配与回收;将逻辑设备名映射为物理设备名；对设备进行保护，禁止用户直接访问设备；缓冲管理；差错控制；提供独立于设备的大小统一的逻辑块，屏蔽设备之间信息交换单位大小和传输速率的差异
2. **`向用户层(或文件层)提供统一接口`**。无论何种设备，它们向用户所提供的接口应是相同的。例如，对各种设备的读/写操作，在应用程序中都统一使用`read/write`命令等

- **设备驱动程序**

**`与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序`**
通常，**`每类设备配置一个设备驱动程序`**，它是I/O进程与设备控制器之间的通信程序，通常以进程的形式存在

设备驱动程序向上层用户程序提供一组标准接口，设备具体的差别被设备驱动程序所封装，用于接收上层软件发来的抽象I/O要求，如`read/write`命令，转换为具体要求后，发送给设备控制器，控制I/O设备工作；它也将由设备控制器发来的信号传送给上层软件，从而为I/O内核子系统隐藏设备控制器之间的差异

- **中断处理程序**

**`用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的现场后，返回到被中断进程`**

中断处理层的主要任务有：进行进程上下文的切换，对处理中断信号源进行测试，读取设备状态和修改进程状态等
由于中断处理与硬件紧密相关，对用户而言，应尽量加以屏蔽，因此应放在操作系统的底层，系统的其余部分尽可能少地与之发生联系

---

**用户对设备的一次命令各层次的处理过程**：

1. 当用户要读取某设备的内容时，通过操作系统提供的`read`命令接口，这就经过了**`用户层`**
2. 操作系统提供给用户使用的接口一般是统一的通用接口，也就是**`几乎每个设备都可以响应的统一命令`**，如`read`命令，用户发出的`read`命令，首先经过**`设备独立层`**进行解析，然后交往下层
3. 接下来，不同类型的设备对`read`命令的行为有所不同，如磁盘接收`read`命令后的行为与打印机接收`read`命令后的行为是不同的。因此，需要针对不同的设备，将`read`命令解析成不同的指令，这就经过了**`设备驱动层`**
4. 命令解析完毕后，需要中断正在运行的进程，转而执行**`read`**命令，这就需要**`中断处理程序`**
5. 最后，命令真正抵达硬件设备，硬件设备的控制器按照上层传达的命令操控硬件设备，完成相应的功能

### 应用程序I/O接口

**1、I/O接口的分类**

在I/O系统与高层之间的接口中，根据**`设备类型的不同`**，又进一步分为若干类：

- **字符设备接口**

字符设备是指数据的存取和传输是**`以字符为单位`**的设备，如键盘、打印机等

基本特征是**`传输速率较低`**、**`不可寻址`**，并且在输入/输出时通**`常采用中断驱动方式`**

`get`和`put`操作。由于字符设备不可寻址，**`只能采取顺序存取方式`**，通常为字符设备**`建立一个字符缓冲区`**，用户程序通过`get`操作**`从缓冲区获取字符`**，通过`put`操作**`将字符输出到缓冲区`**

`in-control`指令。字符设备类型繁多，差异甚大，因此在接口中提供一种通用的`in-control`指令来处理它们(包含了许多参数，每个参数表示一个与具体设备相关的特定功能)。**`字符设备都属于独占设备，为此接口中还需要提供打开和关闭操作，以实现互斥共享`**

- **块设备接口**

块设备是指数据的存取和传输是**`以数据块为单位`**的设备，典型的块设备是磁盘

基本特征是**`传输速率较高、可寻址`**。磁盘设备的I/O**`常采用DMA方式`**

**`隐藏了磁盘的二维结构`**。在二维结构中，每个扇区的地址需要用磁道号和扇区号来表示。块设备接口将磁盘的所有扇区从`0`到`n-1`依次编号，这样，就将二维结构变为一种线性序列

**`将抽象命令映射为低层操作`**。块设备接口支持上层发来的对文件或设备的打开、读、写和关闭等抽象命令，该接口将上述命令映射为设备能识别的较低层的具体操作

**`内存映射接口通过内存的字节数组来访问磁盘，而不提供读/写磁盘操作`**。映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址。只在需要访问内存映像时，才由虚拟存储器实际调⻚。内存映射文件的访问如同内存读/写一样简单，极大地方便了程序员

- **网络设备接口**

现代操作系统都提供面向网络的功能，因此还需要提供相应的网络软件和网络通信接口，使计算机能够通过网络与网络上的其他计算机进行通信或上网浏览

许多操作系统提供的网络I/O接口网络套接字接口，套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此连接发送和接收数据

**2、阻塞I/O和非阻塞I/O**

操作系统的I/O接口还涉及两种模式：**`阻塞和非阻塞`**

- **阻塞I/O**

指**`当用户进程调用I/O操作时，进程就被阻塞，并移到阻塞队列，I/O操作完成后，进程才被唤醒，移到就绪队列`**
当进程恢复执行时，它收到系统调用的返回值，并继续处理数据。大多数操作系统提供的I/O接口都是采用阻塞I/O

优点：**`操作简单，实现难度低，适合并发量小的应用开发`**
缺点：**`I/O执行阶段进程会一直阻塞下去`**

- **非阻塞I/O**

指**`当用户进程调用I/O操作时，不阻塞该进程，但进程需要不断询问I/O操作是否完成，在I/O执行阶段，进程还可以做其他事情`**
当问到I/O操作完成后，系统将数据从内核复制到用户空间，进程继续处理数据

优点：**`进程在等待IO期间不会阻塞，可以做其他事情，适合并发量大的应用开发`**
缺点：**`轮询方式询问I/O结果，会占用CPU的时间`**

### 本节小结

`I/O管理要完成哪些功能?`

```
I/O管理需要完成以下4部分内容：
状态跟踪。要能实时掌握外部设备的状态
设备存取。要实现对设备的存取操作
设备分配。在多用户环境下，负责设备的分配与回收
设备控制。包括设备的驱动、完成和故障的中断处理
```

---

提醒：

```
共享设备必须是可寻址的可随机访问的设备，若不是，则不能保证数据的完整性和一致性
DMA主要用于块设备，因此磁盘设备的I/O控制主要采取DMA方式
设备的固有属性决定了设备的使用方式
设备独立性可以提高设备分配的灵活性和设备的利用率
设备安全性可以保证分配设备时不会导致永久阻塞
设备分配时一般无需考虑及时性，及时性是一个与系统性能和用户需求相关的因素，设备分配时应该考虑的问题是如何再保证系统安全和正确运行的前提下，合理地分配和利用设备资源
系统为每台设备确定一个编号以便区分和识别设备的编号称为绝对号
通道控制设备控制器、设备控制器控制设备工作，三者关系层层递进
将系统调用参数翻译成设备操作命令的工作由设备无关的操作系统软件完成
设备无关的操作系统软件是I/O软件的一部分，它向上层提供系统调用的接口，根据设备类型选择调用相应的驱动程序
设备驱动程序负责执行操作系统发出的I/O命令，因设备的不同而不同
在程序直接控制方式下，用户进程在I/O过程中不会被阻塞，驱动程序完成用户进程的I/O请求后才结束，CPU和I/O操作串行
在中断控制方式下，驱动程序启动第一次I/O操作后，将调出其他进程执行，而当前用户进程被阻塞，CPU和设备准备并行
在DMC方式下，驱动程序执行调度程序，转其他进程执行，当前用户进程被阻塞时，CPU和是数据传送并行
中断处理结束后，是否返回到被中断的进程，有两种情况：
1、采用的是屏蔽中断方式(单重中断)，此时会返回被中断的进程
2、采用的是中断嵌套方式(多重中断)，若没有更搞优先级的中断请求，则会返回被中断的进程；否则系统将处理更高优先级的中断请求
```

## 设备独立性软件

### 设备独立性软件

也称与`设备无关的软件`，是**`I/O系统的最高层软件`**，它的**`下层是设备驱动程序`**，其界限因操作系统和设备的不同而有所差异。总体而言，**`设备独立性软件包括执行所有设备公有操作的软件`**

### 高速緩存与緩沖区

**1、磁益高速媛存(Disk Cache)**

操作系统中**`使用磁盘高速缓存技术来提高磁盘的I/O速度`**，**`访问高速缓存比访问原始磁盘数据更为高效`**

磁盘高速缓存技术是指**`利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息`**。因此，磁盘高速缓存**`逻辑上属于磁盘`**，**`物理上则是驻留在内存中的盘块`**

磁盘高速缓存在内存中分为两种形式：
一种是**`在内存中开辟一个单独的空间作为缓存区，大小固定`**
另一种是**`将未利用的内存空间作为一个缓冲池，供请求分⻚系统和磁盘I/O时共享`**

**2、緩沖区(Buffer)**

在设备管理子系统中，引入缓冲区的目的主要如下：

1. **`缓和CPU与I/O设备间速度不匹配的矛盾`**
2. **`减少对CPU的中断频率`**，放宽对CPU中断响应时间的限制
3. 解决基本数据单元大小(数据粒度)不匹配的问题
4. **`提高CPU和I/O设备之间的并行性`**

缓冲区的实现方法如下：

1. **`采用硬件缓冲器`**，但由于成本太高，除一些关键部位外，一般不采用硬件缓冲器
2. **`利用内存作为缓冲区`**

根据系统设置缓冲区的个数，缓冲技术可以分为如下几种：

- **单缓冲**

**`每当用户进程发出一个I/O请求，操作系统便在内存中之分配一个缓冲区`**。通常，**`一个缓冲区的大小就是一个块`**

![image-20240425104731016](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425104731016.png)

在块设备输入时，假定从设备`将一块数据输入到缓冲区的时间`为`T`，操作系统`将该缓冲区中的数据传送到工作区的时间`为`M`，而`CPU对这一块数据进行处理的时间`为`C`。注意，**`必须等缓冲区冲满后才能从缓冲区中取出数据`**

**`在单缓冲区中，T是可以和C并行的`**

当`T>C`时，CPU处理一块完数据后，暂时不能将下一块数据传送到工作区，必须等待缓冲区装满数据，再将下一块数据从缓冲区传送到工作区，平均处理一块数据的时间为`T+M`
当`T<C`时，缓冲区中装满数据后，暂时不能继续送入下一块数据，必须等待CPU处理完上一块数据，再将下一块数据从缓冲区传送到工作区，平均处理一块数据的时间为`C+M`
总结：单缓冲区处理每块数据的平均时间为`Max(C,T)+M`

由于缓冲区是共享资源，因此**`使用时必须互斥`**。若CPU尚未取走缓冲区中的数据，则即使设备又生产出新的数据，也无法将其送入缓冲区，此时设备需要等待

- **双缓冲**

为了加快输入和输出速度，提高设备利用率，引入了`双缓冲机制`，也称`缓冲对换`

![image-20240425105231633](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425105231633.png)

当设备输入数据时，先将数据送入缓冲区1，装满后便转向缓冲区2
此时，操作系统可以从缓冲区1中取出数据，送入用户进程，并由CPU对数据进行处理
当缓冲区1中取出的数据处理完后，若缓冲区2已冲满，则操作系统又从缓冲区2中取出数据送入用户进程处理，而设备又可以开始将数据送入缓冲区1

**`双缓冲机制提高了设备和CPU的并行程度`**

设备输入数据到缓冲区、数据传送到用户进程和处理的时间分别为`T`、`M`和`C`
在双缓冲区中，**`C和M是可以与T并行的`**

当`T>C+M`时，说明**`设备输入的时间比数据传送和处理的时间多，可使设备连续输入`**。假设在某个时刻，缓冲区1是空的，缓冲区2是满的，缓冲区2开始向工作区传送数据，缓冲区1开始装入数据。传送并处理的时间为`C+M`，但缓冲区1还未装满，必须等待缓冲区1装满数据，再将下一块数据从缓冲区1传送到工作区，平均处理一块数据的时间为`T`
当`T<C+M`时，说明**`设备输入的时间比数据传送和处理的时间少，可使CPU不必等待设备输入`**。假设在某个时刻，缓冲区1是空的，缓冲区2是满的，缓冲区2开始向工作区传送数据，缓冲区1开始装入数据。缓冲区1装满数据的用时为`T`，必须等待缓冲区2中的数据传送并处理完后，才能将下一块数据从缓冲区1传送到工作区，平均处理一块数据的时间为`C+M`
总结：双缓冲区处理每块数据的平均时间为`Max(C+M,T)`

若两台机器之间仅配置了单缓冲

![image-20240425105926292](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425105926292.png)

则它们**`在任意时刻都只能实现单方向的数据传输`**，而绝**`不允许双方同时向对方发送数据`**

为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，**`一个用作发送缓冲区，另一个用作接收缓冲区`**

![image-20240425105934200](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425105934200.png)

注：

```
在双缓冲机制中，当输入与输出的速度基本匹配时，能取得较好的效果
但若两者的速度相差甚远，则双缓冲区的效果不会太理想
```

- **循环缓冲**

多缓冲机制，**`让多个缓冲区组成循环缓冲区的形式`**。灰色表示已装满数据的缓冲区，白色表示空缓冲区

![image-20240425110216877](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425110216877.png)

循环缓冲**`包含多个大小相等的缓冲区`**，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区链接成一个循环队列

循环缓冲中还需设置`in`和`out`两个指针，`in`指向**`第一个可以输入数据的空缓冲区`**，`out`指向**`第一个可以提取数据的满缓冲区`**。输入/输出时，**`in和out指针沿链接方向循环移动`**

- **缓冲池**

相比于缓冲区(仅是一块内存空间)，缓冲池是**`包含一个用于管理自身的数据结构和一组操作函数的管理机制，用于管理多个缓冲区`**。缓冲池**`可供多个进程共享使用`**

缓冲池由多个系统公用的缓冲区组成，缓冲区按其使用状况可以分为：

1. **空缓冲队列**，由空缓冲区链接而成的队列
2. **输入队列**，由装满输入数据的缓冲区链接而成的队列
3. **输出队列**，由装满输出数据的缓冲区所链接成的队列

此外还应具有4种工作缓冲区：

1. 用于**`收容输入`**数据的工作缓冲区`(hin)`
2. 用于**`提取输入`**数据的工作缓冲区`(sin)`
3. 用于**`收容输出`**数据的工作缓冲区`(hout)`
4. 用于**`提取输出`**数据的工作缓冲区`(sout)`

![image-20240425110754792](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425110754792.png)

缓冲池中的缓冲区有以下4种工作方式：

1. **收容输入**。**`输入进程`**需要**`输入数据`**时，从**`空缓冲队列的队首摘下一个空缓冲区`**，作为收容输入工作缓冲区，然后**`将数据输入`**其中，**`装满`**后再将它**`挂到输入队列的队尾`**
2. **提取输入**。**`计算进程`**需要**`输入数据`**时，从**`输入队列的队首取得一个缓冲区`**，作为提取输入工作缓冲区，从中**`提取数据`**，**`用完该数据`**后将它**`挂到空缓冲队列的列尾`**
3. **收容输出**。**`计算进程`**需要**`输出数据`**时，从**`空缓冲队列的队首取得一个空缓冲区`**，作为收容输出工作缓冲区，当其中**`装满数据后`**，再将它**`挂到输出队列的队尾`**
4. **提取输出**。**`输出进程`**需要**`输出数据`**时，从**`输出队列的队首取得一个装满输出数据的缓冲区`**，作为提取输出工作缓冲区，当**`数据提取完后`**，再将它**`挂到空缓冲队列的队尾`**

---

高速缓存与缓冲区的对比：

高速缓存是**`可以保存数据拷⻉的高速存储器`**，访问高速缓存比访问原始数据更高效，速度更快

![image-20240425111412780](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425111412780.png)

### 设备分配与回收

**1、设备分配概述**

设备分配是指**`根据用户的I/O请求分配所需的设备`**
分配的总原则：**`充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁`**

**2、设备分配的数据结构**

在系统中，可能存在多个通道，每个通道可以连接多个控制器，每个控制器可以连接多个物理设备
设备分配的数据结构要能体现出这种从属关系，各数据结构的介绍如下：

- **设备控制表(DCT)**

系统为**`每个设备配置一张DCT`**，表中的表项就是设备的各个属性

![image-20240425163803267](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425163803267.png)

在DCT中，应该有下列字段：

```
设备类型：表示设备类型，如打印机、扫描仪、键盘等
设备标识符：即物理设备名，每个设备在系统中的物理设备名是唯一的
设备状态：表示当前设备的状态(忙/闲)
指向控制器表的指针：每个设备由一个控制器控制，该指针指向对应的控制器表
重复执行次数或时间：重复执行次数达到规定值仍不成功时，才认为此次I/O失败
设备队列的队首指针：指向正在等待该设备的进程队列(由进程PCB组成)的队首
```

注：`当某个进程释放某个设备，且无其他进程请求该设备时，系统将该设备DCT中的设备状态改为空闲，即可实现“设备回收”`

- **控制器控制表(COCT)**

**`每个设备控制器都对应一张COCT`**

![image-20240425164137386](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425164137386.png)

操作系统根据COCT的信息**`对控制器进行操作和管理`**。**`每个控制器由一个通道控制`**，通过表项`与控制器连接的通道表指针`可以找到相应通道的信息

- **通道控制表(CHCT)**

**`每个通道都对应一张CHCT`**

![image-20240425164252524](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425164252524.png)

操作系统根据CHCT的信息**`对通道进行操作和管理`**。**`一个通道可为多个控制器服务`**，通过表项`与通道连接的控制器表首址`可以找到该通道管理的所有控制器的信息

- **系统设备表(SDT)**

**`整个系统只有一张SDT`**

![image-20240425164355417](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425164355417.png)

它**`记录已连接到系统中的所有物理设备的情况`**，**`每个物理设备对应一个表目`**

**3、设备分配时应考虑的因素**

在多道程序系统中，进程数多于资源数，因此要有一套合理的分配原则，主要考虑的因素有设备的固有属性、设备的分配算法、设备分配的安全性以及设备的独立性

- **设备的固有属性**

设备的固有属性可分成三种，对它们应采取不同的分配策略：

1. **独占设备**：将它分配给某个进程后，便由该进程独占，直至进程完成或释放该设备
2. **共享设备**：可将它同时分配给多个进程，需要合理调度各个进程访问该设备的先后次序
3. **虚拟设备**：虚拟设备**`属于可共享设备`**，可将它同时分配给多个进程使用

- **设备分配算法**

针对设备分配，通常只采用以下两种分配算法：

1. **FCFS算法**。该算法根据各个进程对某个设备提出请求的先后次序，将这些进程**`排成一个设备请求队列`**，设备分配程序**`总是将设备首先分配给队首进程`**
2. **最高优先级优先算法**。在用该算法形成设备队列时，**`优先级高的进程排在设备队列前面`**，而**`对于优先级相同的I/O请求，则按FCFS原则排队`**

- **设备分配中的安全性**

设备分配中的安全性是指**`在设备分配中应防止发生进程死锁`**

1. **安全分配方式**
   每当进程发出I/O请求后，便进入阻塞态，直到其I/O操作完成时才被唤醒
   这样，**`进程一旦获得某种设备后便会阻塞`**，不能再请求任何资源，而在它阻塞时也不保持任何资源
   其优点是**`设备分配安全`**；缺点是**`CPU和I/O设备是串行工作的`**
2. **不安全分配方式**
   进程**`在发出I/O请求后仍继续运行`**，需要时又会发出第二个、第三个I/O请求等
   **`仅当进程所请求的设备已被另一进程占用时，才进入阻塞态`**
   优点是**`一个进程可同时操作多个设备，使进程推进迅速`**；缺点是**`有可能造成死锁`**

**4、设备分配的步骤**

下面以独占设备为例，介绍设备分配的过程

1. **分配设备**。首先根据I/O请求中的物理设备名，查找SDT，从中找出该设备的DCT，再根据DCT中的设备状态字段，可知该设备的状态。若忙，则将进程PCB挂到设备等待队列中；若不忙，则根据一定的策略将设备分配给该进程
2. **分配控制器**。设备分配后，根据DCT找到COCT，查询控制器的状态。若忙，则将进程PCB挂到控制器等待队列中；若不忙，则将控制器分配给该进程
3. **分配通道**。控制器分配后，根据COCT找到CHCT，查询通道的状态。若忙，则将进程PCB挂到通道等待队列中；若不忙，则将通道分配给该进程
4. 只有设备、控制器和通道都分配成功时，这次的设备分配才算成功，之后便可启动设备进行数据传送

在上面的例子中，**`进程是以物理设备名提出I/O请求的`**。若指定设备已分配给其他进程，则该进程分配失败，或者说上面的设备分配程序不具有设备无关性。**`为了获得设备的独立性，进程应使用逻辑设备名`**。这样，系统首先从SDT中找出第一个**`该类`**设备的DCT。若该设备忙，则查找第二个该类设备的DCT，仅当所有该类设备都忙时，才将进程挂到该类设备的等待队列上。而只要有一个该类设备可用，系统便进入进一步的分配操作

**5、逻辑设备名到物理设备名的映射**

为了**`实现设备的独立性`**，进程中应使用`逻辑设备名`来请求某类设备
因为系统只识别物理设备名，因此在系统中需要配置一张`逻辑设备表`，用于**`将逻辑设备名映射为物理设备名`**

**`逻辑设备表(LUT)`**的每个表项中包含3项内容：`逻辑设备名`、`物理设备名`和`设备驱动程序的入口地址`
当进程用逻辑设备名来请求分配设备时，系统会为它分配一台相应的物理设备，并在LUT中建立一个表目，填上相应的信息，当以后进程再利用该逻辑设备名请求I/O操作时，系统通过查找LUT来寻找对应的物理设备及其驱动程序

在系统中，可采取两种方式设置逻辑设备表：

1. **`整个系统中只设置一张LUT`**。所有进程的设备分配情况都记录在同一张LUT中，这就**`要求所有用户不能使用相同的逻辑设备名`**，主要**`适用于单用户系统`**
2. **`为每个用户设置一张LUT`**。系统为每个用户设置一张LUT，同时在多用户系统中都配置系统设备表。因此，**`不同用户可以使用相同的逻辑设备名`**

![image-20240425165902736](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425165902736.png)

### SPOOLing技术(假脱机技术)

**`为了缓和CPU的高速性与I/O设备的低速性之间的矛盾`**，引入了`假脱机技术`，它是操作系统中采用的一项**`将独占设备改造成共享设备的技术`**

该技术利用**`专⻔的外围控制机`**，先**`将低速I/O设备上的数据传送到高速磁盘上，或者相反`**
当**`CPU需要输入数据时`**，便**`可直接从磁盘中读取数据`**；当**`CPU需要输出数据时`**，也**`能以很快的速度将数据先输出到磁盘上`**

引入多道程序技术后，系统便**`可利用程序来模拟脱机输入/输出时的外围控制机，在主机的直接控制下实现脱机输入/输出功能`**

SPOOLing系统的组成如下所示：

![image-20240425170303846](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240425170303846.png)

- **输入井和输出井**

在**`磁盘上`**开辟出的两个存储区域

**`输入井模拟脱机输入时的磁盘，用于收容I/O设备输入的数据`**
**`输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据`**

一个进程的输入(或输出)数据保存为一个文件，所有进程的输入(或输出)文件链接成一个输入(或输出)队列

- **输入缓冲区和输出缓冲区**

在**`内存中`**开辟的两个缓冲区

**`输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井`**
**`输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备`**

起到暂存作用，暂存在内存中

- **输入进程和输出进程**

**`输入进程`**用于**`模拟脱机输入时的外围控制机`**，**`将用户要求的数据从输入设备传送到输入缓冲区，再存放到输入井中`**。当CPU需要输入数据时，直接从输入井中读入内存
**`输出进程`**用于**`模拟脱机输出时的外围控制机`**，**`将用户要求输入的数据从内存传送到输出井，待输出设备空闲时，再将输出井中的数据经输出缓冲区输出至输出设备`**

- **井管理程序**

**`用于控制作业与磁盘井之间信息的交换`**

打印机是典型的独占设备，利用SPOOLing技术可将它改造为一台可供多个用户共享的打印设备

当多个用户进程发出打印输出请求时，SPOOLing系统同意它们的请求，但并不真正立即将打印机分配给它们，而由假脱机管理进程为每个进程做如下两项工作：

1. **`在磁盘缓冲区中为进程申请一个空闲盘块`**，并将要打印的**`数据送入其中暂存`**
2. 为用户进程**`申请一张空白的用户请求打印表`**，并将用户的打印要求填入其中，再**`将该表挂到假脱机文件队列上`**

对每个用户进程而言，系统并非即时执行真实的打印操作，而只是即时将数据输出到缓冲区，这时的数据并未被真正打印，而只让用户感觉系统已为它打印，真正的打印操作是在打印机空闲且该打印任务在等待队列中己排到队首时进行的

以上过程用户是不可⻅的。虽然系统中只有一台打印机，但是当进程提出打印请求时，系统都在输出井中为其分配一个缓冲区(相当于分配一台逻辑设备)，使每个进程都觉得自己正在独占一台打印机，从而实现对打印机的共享

SPOOLing系统的特点：

1. **`提高了I/O速度`**，将对低速I/O设备执行的操作演变为对磁盘缓冲区中数据的存取操作，如同脱机输入/输出一样，**`缓和了CPU和低速I/O设备之间速度不匹配的矛盾`**
2. **`独占设备改造为共享设备`**，在假脱机打印机系统中，**`实际上并没有为任何进程分配设备`**
3. **`实现了虚拟设备功能`**，对每个进程而言，它们都认为自己独占了一台设备

### 设备驱动程序接口

**`设备驱动程序是I/O系统的上层与设备控制器之间的通信程序`**，其主要任务是**`接收上层应用发来的抽象I/O请求`**，如`read`或`write`命令，**`将它们转换为具体要求后发送给设备控制器，进而使其启动设备去执行任务`**；反之，它**`也将设备控制器发来的信号传送给上层应用`**

为了实现上层应用与设备控制器之间的通信，设备驱动程序应具有以下功能：

1. **`接收`**由上层软件发来的**`命令和参数`**，并**`将抽象要求转换为与设备相关的具体要求`**。例如，将抽象要求中的盘块号转换为磁盘的盘面号、磁道号及扇区号
2. **`检查`**用户I/O请求的**`合法性`**，**`了解`**设备的**`工作状态`**，**`传递`**与设备操作有关的**`参数`**，**`设置`**设备的**`工作方式`**
3. 发出I/O命令，若设备**`空闲`**，则**`立即启动`**它，完成指定的I/O操作；若设备**`忙`**，则**`将请求者的PCB挂到设备队列上等待`**
4. 及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理

相比于普通的应用程序和系统程序，设备驱动程序具有以下差异：

1. 设备驱动程序将抽象的I/O请求转换成具体的I/O操作后，传送给设备控制器，并将设备控制器中记录的设备状态和I/O操作的完成情况及时地反馈给请求进程
2. 设备驱动程序**`与设备采用的I/O控制方式紧密相关`**，常用的I/O控制方式是**`中断驱动方式`**和**`DMA方式`**
3. 设备驱动程序**`与硬件密切相关`**，对于**`不同类型的设备，应配置不同的设备驱动程序`**
4. 由于设备驱动程序与硬件紧密相关，目前很多设备驱动程序的基本部分已固化在ROM中
5. 设备驱动程序应**`允许同时多次调用执行`**

为了使所有的设备驱动程序都有统一的接口：

- 一方面，要求**`每个设备驱动程序与操作系统之间都有相同或相近的接口`**，以便更容易地添加一个新的设备驱动程序，同时更容易地编制设备驱动程序
- 另一方面，要**`将抽象的设备名转换为具体的物理设备名`**，并且进一步找到相应的设备驱动程序入口
- 此外，还应**`对设备进行保护，防止无权访问的用户使用设备`**

### 本节小结

`当处理机和外部设备的速度差距较大时，有什么办法可以解决问题?`

```
可采用缓冲技术来缓解CPU与外设速度上的矛盾
即在某个地方(一般为主存)设立一片缓冲区，外设与CPU的输入/输出都经过缓冲区，这样外设和CPU就都不用互相等待
```

`什么是设备的独立性?引入设备的独立性有什么好处?`

```
设备独立性是指用户在编程序时使用的设备与实际设备无关
一个程序应独立于分配给它的某类设备的具体设备，即在用户程序中只指明I/O使用的设备类型即可

设备独立性有以下优点：
1、方便用户编程
2、使程序运行不受具体机器环境的限制
3、便于程序移植
```

---

提醒：

```
设备的独立性是指用户使用设备的透明性，因此用户编程时使用的设备与实际使用的设备无关
缓冲池是系统的共用资源，可供多个进程共享，并且既能用于输入，又能用于输出。一般包含三种类型的缓冲：1、空闲缓冲区；2、装满输入数据的缓冲区；3、装满输出数据的缓冲区。为了管理上的方便，可将相同类型的缓冲区链成一个队列
支持双向发送和接收数据的设备应使用双缓冲区，双缓冲区可以实现同一时刻的双向数据传输，提高设备的效率和利用率
单缓冲区只能实现单向数据传输
多缓冲区和缓冲池是用于提高I/O性能的技术，但不是必须的，也不一定适合所有的双向设备
使用单缓冲或双缓冲进行通信时，都可以实现数据的双向传输。单缓冲只是不同时刻收发数据，是可以进行双向传输的
在鼠标移动式，若有高优先级的操作产生，为例记录鼠标活动的情况，必须使用缓冲技术
由于磁盘驱动器和目标或源I/O设备间的吞吐量不同，必须采用缓冲技术
为了能使数据从用户作业空间传送到磁盘或从磁盘传送到用户作业空间，必须采用缓冲技术
单机资源利用率最关键的资源使处理器资源，最大化地提高处理器利用率就能最大化的提高系统效率
多道程序设计技术使提高处理器利用率的关键技术，而如SPOOLing技术、虚拟技术、交换技术这些都属于设备和内存的相关技术
SPOOLing技术需要使用磁盘空间(输入井和输出井)和内存空间(输入/输出缓冲区)，不需要外围计算机的支持
SPOOLing系统由预输入程序(输入进程和输入缓冲区)、井管理程序(输入井和输出井)和缓输出程序(输出进程和输出缓冲区)组成
构成SPOOLing系统的基本条件：不仅要有大容量、高速度的外村作为输入井和输出井，而且还要有SPOOLing软件的支持
利用SPOOLing技术提高了系统和I/O设备的利用率，不必等待I/O操作完成
SPOOLing技术将独占设备虚拟成共享设备，因此必须先有独占设备才行
设备寄存器写命令是由设备驱动程序完成的
检查用户是否有权使用设备属于设备保护，使由设备独立性软件完成的
将二进制整数转换成ASCII码的格式打印时通过I/O库函数完成的，属于用户层软件
缓冲区管理属于输入/输出的共有操作，是由设备独立性软件完成的
对I/O设备传回的数据进行分析和缓冲由操作系统完成
设备驱动程序的处理过程：
1、将抽象要求转化为具体要求
2、对服务请求进行校验
3、检查设备状态
4、传送必要的参数
5、启动I/O设备
计算柱面号、磁头号和扇区号的工作是由设备驱动程序完成的
磁盘和内存速度差异，决定了可以将内存经常访问的文件调入磁盘缓冲区，高速缓存中复制的访问比磁盘I/O的机械操作要块很多
SPOOLing利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上，或者相反
SPOOLing技术建立在多道程序设计技术的基础上，在一个时间段内，输入进程、输出进程是可以和运行的作业进程并发执行的
设备输入井/输出井之间数据的传送是由系统实现的
```

## 磁盘和固态硬盘

### 磁盘

磁盘通过一个称为磁头的导体线圈从磁盘存取数据，在读/写操作期间，磁头固定，磁盘在下面高速旋转

![image-20240426200709233](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426200709233.png)

磁盘盘面上的数据存储在一组同心圆中，称`磁道`。每个磁道与磁头一样宽，一个盘面有上千个磁道。磁道又划分为几百个`扇区`，**`每个扇区固定存储大小`**，一个扇区称为一个`盘块`

**`相邻磁道及相邻扇区间通过一定的间隙分隔开，以避免精度错误`**
**`由于扇区按固定圆心⻆度划分，所以密度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度`**

注：

```
为了提高磁盘的存储容量，充分利用磁盘外层磁道的存储能力，现代磁盘不再将内外磁道划分为相同数目的扇区，而将盘面划分为若干环带，同一环带内的所有磁道具有相同的扇区数，显然，外层环带的磁道拥有较内层环带的磁道更多的扇区
```

磁盘安装在一个磁盘驱动器中，它由磁头臂、用于旋转磁盘的转轴和用于数据输入/输出的电子设备组成：

![image-20240426200726068](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426200726068.png)

多个盘片垂直堆叠，组成磁盘组，每个盘面对应一个磁头，所有磁头固定在一起，与磁盘中心的距离相同且只能`共进退`
所有盘片上相对位置相同的磁道组成柱面
**`扇区是磁盘可寻址的最小单位`**，磁盘上能存储的物理块数目由**`扇区数、磁道数及磁盘面数`**决定，磁盘地址用**`柱面号-盘面号-扇区号`**表示

磁盘按不同的方式可分为若干类型：

1. 固定头磁盘，磁头相对于盘片的径向方向固定，这种磁盘中的每个磁道有一个磁头
2. 活动头磁盘，磁头可移动，磁头臂可来回伸缩定位磁道
3. 固定盘磁盘，盘片永久固定在磁盘驱动器内
4. 可换盘磁盘，盘片可移动和替换

### 磁盘的管理

**1、磁盘初始化**

一个新的磁盘只是一个磁性记录材料的空白盘
**`在磁盘可以存储数据之前，必须将它分成扇区，以便磁盘控制器能够进行读/写操作`**，这个过程称为`低级格式化`(或称`物理格式化`)

每个扇区通常由头部、数据区域和尾部组成
头部和尾部包含了一些磁盘控制器的使用信息，其中**`利用磁道号、磁头号和扇区号来标志一个扇区`**，**`利用CRC字段对扇区进行校验`**

**2、分区**

在可以使用磁盘存储文件之前，还要完成两个步骤：

1. **`将磁盘分区`**，每个分区由一个或多个柱面组成，每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中
2. **`对物理分区进行逻辑格式化`**(也称**`高级格式化`**)，将初始文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配空间，以及一个初始为空的目录，建立根目录、对保存空闲磁盘块信息的数据结构进行初始化

因扇区的单位太小，**`为了提高效率，操作系统将多个相邻的扇区组合在一起`**，形成一**`簇`**(在Linux中称为**`块`**)
**`为了更高效地管理磁盘，一簇只能存放一个文件的内容`**，文件**`所占用的空间只能是簇的整数倍`**

**3、引导块**

计算机启动时需要运行一个`初始化程序`(`自举程序`)，它初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统
自举程序**`找到磁盘上的操作系统内核`**，将它**`加载到内存`**，并**`转到起始地址`**，从而**`开始操作系统的运行`**。

自举程序**`通常存放在ROM`**中，为了避免改变自举代码而需要改变ROM硬件的问题，通常只在ROM中保留很小的自举装入程序，而**`将完整功能的引导程序保存在磁盘的启动块上`**，启动块**`位于磁盘`**的固定位置。具有启动分区的磁盘称为`启动磁盘`或`系统磁盘`

引导ROM中的代码指示磁盘控制器将引导块读入内存，然后开始执行，它可以从非固定的磁盘位置加载整个操作系统，并且开始运行操作系统

下面以Windows为例来分析引导过程：

1. Windows允许将磁盘分为多个分区，有一个分区引导分区，它包含操作系统和设备驱动程序
2. Windows系统将引导代码存储在磁盘的第0号扇区，它称主引导记录(MBR)
3. 引导首先运行ROM中的代码，这个代码指示系统从MBR中读取引导代码
4. 除了包含引导代码，MBR还包含一个磁盘分区表和一个标志(以指示从哪个分区引导系统)
5. 当系统找到引导分区时，读取分区的第一个扇区，称为引导扇区，并继续余下的引导过程，包括加载各种系统服务

![image-20240426203038012](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426203038012.png)

**4、坏块**

由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏。根据所用的磁盘和控制器，对这些块有多种处理方式

对于简单磁盘，如采用IDE控制器的磁盘，坏块可手动处理，如`MS-DOS`的`Format`命令执行逻辑格式化时会扫描磁盘以检查坏块。坏块在`FAT`表上会标明，因此程序不会使用它们

对于复杂的磁盘，控制器维护磁盘内的坏块列表。这个列表在出厂低级格式化时就已初始化，并在磁盘的使用过程中不断更新。低级格式化将一些块保留作为备用，操作系统看不到这些块。控制器可以**`采用备用块来逻辑地替代坏块`**，这种方案称为`扇区备用`

对坏块的处理实质上就是用某种机制使系统不去使用坏块

### 磁盘调度算法

**1、磁盘的存取时间**

一次磁盘读/写操作的时间**`由寻找(寻道)时间、旋转延迟时间和传输时间决定`**

- **寻道时间`Ts`**

活动头磁盘在读/写信息前，**`将磁头移动到目的磁道所需的时间`**，这个时间除**`跨越 n 条磁道的时间`**外，还包括**`启动磁头臂的时间 s`**，`m`是**`与磁盘驱动器速度有关的常数`**(越为2ms)
$$
Ts = m*n+s
$$

- **旋转延迟时间`Tr`**

磁头**`定位到要读/写扇区所需的时间`**，设**`磁盘的旋转速度为 r`**，有：
$$
Tr={1}/{2r}
$$
注：**`题目中一般是告诉你转速，最好别太依赖公式，最好求一下转一周需要的时间`**

- **传输时间`Tt`**

**`从磁盘读出或向磁盘写入数据所需的时间`**，这个时间**`取决于每次所读/写的字节数 b 和磁盘的旋转速度 r`**，`N`一个**`磁道上的字节数`**
$$
Tt=b/rN
$$

---

**总平均存取时间`Ta`**可以表示为：
$$
Ta=Ts+1/2r+b/rN
$$
**2、磁盘调度算法**

在磁盘的存取时间中，**`寻道时间`**占大头，它**`与磁盘调度算法密切相关`**
**`延迟时间和传输时间`**都**`与磁盘旋转速度线性相关`**，所以转速是磁盘性能的一个非常重要的硬件参数，也很难从操作系统层面进行优化。因此，磁盘调度的**`主要目标是减少磁盘的平均寻道时间`**

目前常用的磁盘调度算法有以下几种：

- **先来先服务(FCFS)算法**

FCFS算法**`根据进程请求访问磁盘的先后顺序进行调度`**，这是一种最简单的调度算法

该算法的优点是**`具有公平性`**

若只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则有望达到较好的性能
若有大量进程竞争使用磁盘，则这种算法在性能上往往接近于随机调度

![image-20240426204713403](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426204713403.png)

- **最短寻道时间优先(SSTF)算法**

SSTF算法**`每次选择调度的是与当前磁头最近的磁道`**，使**`每次的寻道时间最短`**

每次选择最小寻道时间**`并不能保证平均寻道时间最小，但能提供比FCFS算法更好的性能`**

**`这种算法会产生“饥饿”现象`**：在某个磁道附近一直出现新的请求，则离这个磁道较远的磁道将会一直得不到访问

![image-20240426205010360](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426205010360.png)

- **扫描(SCAN)算法**

规定：**`只有磁头移动到最外侧磁道时才能向内移动，移动到最内侧磁道时才能向外移动`**，这就是SCAN算法的思想
**`在SSTF算法的基础上规定了磁头移动的方向`**，由于磁头移动规律与电梯运行相似，因此又称`电梯调度算法`

![image-20240426205142910](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426205142910.png)

SCAN算法**`对最近扫描过的区域不公平`**，因此它**`在访问局部性方面不如FCFS算法和SSTF算法好`**

采用SCAN算法时，不但要知道**`磁头的当前位置`**，而且要知道**`磁头的移动方向`**

- **循环扫描(C-SCAN)算法**

在SCAN算法的基础上规定**`磁头单向移动来提供服务，返回时直接快速移动至起始端而不服务任何请求`**
由于SCAN算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的C-SCAN算法来避免这个问题

![image-20240426205434840](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426205434840.png)

---

采用`SCAN`算法和`C-SCAN`算法时，**`磁头总是严格地遵循从盘面的一端到另一端`**
`LOOK`调度和`C-LOOK`调度则**`磁头只需移动到最远端的一个请求即可返回，不需要到达磁盘端点`**

![image-20240426205721677](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426205721677.png)


注：`若无特别说明，也可默认SCAN算法和C-SCAN算法为LOK调度和C-LOOK调度`

---

以上四种磁盘调度算法的优缺点：

![image-20240426205817284](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426205817284.png)

**3、减少延迟时间的方法**

除减少寻道时间外，**`减少延迟时间`**也是提高磁盘传输效率的重要因素

磁盘是连续自转设备，磁头读入一个扇区后，需要经过短暂的处理时间，才能开始读入下一个扇区
若逻辑上相邻的块在物理上也相邻，则读入几个连续的逻辑块可能需要很⻓的延迟时间
为此，可**`对一个盘面的扇区进行交替编号`**，即**`让逻辑上相邻的块物理上保持一定的间隔`**，于是读入多个连续块时能够减少延迟时间

![image-20240426210043100](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426210043100.png)

此外，由于磁盘的所有盘面是同步转动的，逻辑块在相同柱面上也是按盘面号连续存放的

要读入不同盘面上的连续块，在读完0号盘7号扇区后，还需要一段处理时间，所以当磁头首次划过1号盘0号扇区(下一次要读的块)时，并不能读取，只能等磁头再次划过该扇区时才能读取
为此，可**`对不同的盘面进行错位命名`**，则读入相邻两个盘面的连续块时也能减少延迟时间

![image-20240426210247956](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426210247956.png)

**4、提高磁盘I/O速度的方法**

磁盘的存取时间中，寻道时间和延迟时间属于“找”的时间，凡是“找”的时间都可以通过一定的方法优化，但传输时间是磁盘本身性质所决定的，不能通过一定的措施减少

`文件的访问速度`是衡量文件系统性能最重要的因素，可从以下三个方面来优化：

1. **`改进文件的目录结构及检索目录的方法`**，以减少对目录的查找时间
2. **`选取好的文件存储结构`**，以提高对文件的访问速度
3. **`提高磁盘I/O速度`**，以实现文件中的数据在磁盘和内存之间快速传送

提高磁盘I/O的速度：

1. **采用磁盘高速缓存**
2. **调整磁盘请求顺序**
3. **提前读**。在读磁盘当前块时，将下一磁盘块也读入内存缓冲区
4. **延迟写**。仅在缓冲区首部设置延迟写标志，然后释放此缓冲区并将其链入空闲缓冲区链表的尾部，当其他进程申请到此缓冲区时，才真正将缓冲区信息写入磁盘块
5. **优化物理块的分布**。除了上面介绍的扇区编号优化，当文件采用**`链接方式和索引方式`**组织时，应**`尽量将同一个文件的盘块安排在一个磁道上或相邻的磁道上`**，以減少寻道时间。另外，**`将若干盘块组成簇，按簇对文件进行分配`**，也可减少磁头的平均移动距离
6. **虚拟盘**。是指**`用内存空间去仿真磁盘`**，又叫`RAM盘`。**`常用于存放临时文件`**
7. **采用磁盘阵列RAID**。由于可采用并行交叉存取，因此能大幅提高磁盘I/O速度

### 固态硬盘

**1、固态硬盘的特性**

**固态硬盘(SSD)**是一种**`基于闪存技术的存储器`**，与U盘并无本质差别，只是容量更大，存取性能更好

一个SSD由一个或多个**`闪存芯片`**和**`闪存翻译层`**组成

闪存芯片替代传统磁盘中的机械驱动器，
闪存翻译层将来自CPU的逻辑块读/写请求翻译成对底层物理设备的读/写控制信号，相当于扮演了磁盘控制器的⻆色

![image-20240426211034116](https://gitee.com/DuxianQAQ/picture/raw/master/image-20240426211034116.png)

数据是**`以⻚为单位读/写`**的。**`只有在一⻚所属的块整个被擦除后，才能写这一⻚`**
不过，一旦一个块被擦除，块中的每⻚就都可以直接再写一次
某个块进行了若干重复写后，就会磨损坏，不能再使用

随机写很慢，有两个原因：

1. 擦除块比较慢，通常比访问⻚高一个数量级
2. 如果写操作试图修改一个包含已有数据的⻚ **P~i~** ，那么这个块中所有含有用数据的⻚都必须被复制到一个新(擦除过的)块中，然后才能进行对⻚ **P~i~** 的写操作

比起传统磁盘，SSD有很多优点：它由半导体存储器构成，没有移动的部件，因此随机访问速度比机械磁盘要快很多，也没有任何机械噪声和震动，能耗更低、抗震性好、安全性高等

**2、磨损均衡**

固态硬盘也有缺点，**`闪存的擦写寿命是有限的`**，读/写数据时会集中在SSD的一部分闪存，一旦这部分闪存损坏，整块SSD也就损坏了，为了弥补SSD的寿命缺陷，引入了磨损均衡

SSD磨损均衡技术大致分为两种：

1. **动态磨损均衡**。写入数据时，**`自动选择较新的闪存块`**。老的闪存块先歇一歇
2. **静态磨损均衡**。这种技术更为先进，就算没有数据写入，SSD也会监测并自动进行数据分配，让老的闪存块承担无须写数据的存储任务，同时让较新的闪存块腾出空间，平常的读/写操作在较新的闪存块中进行。如此一来，各闪存块的寿命损耗就都差不多

### 本节小结

`在磁盘上进行一次读/写操作需要哪几部分时间?其中哪部分时间最⻓?`

```
在磁盘上进行一次读/写操作花费的时间由寻道时间、延迟时间和传输时间决定
寻道时间是将磁头移动到指定磁道所需要的时间
延迟时间是磁头定位到某一磁道的扇区(块号)所需要的时间
传输时间是从磁盘读出或向磁盘写入数据所经历的时间

一般来说，寻道时间因为要移动磁头臂，所以占用时间最⻓
```

`存储一个文件时，当一个磁道存储不下时，剩下部分是存在同一个盘面的不同磁道好，还是存在同一个柱面上的不同盘面好?`

```
寻道时间对于一次磁盘访问的影响是最大的，若存在同一个盘面的不同磁道，则磁头臂势必要移动，这样会大大增加文件的访向时间，而存在同一个柱面上的不同盘面就不需要移动磁道，所以一般情况下存在同一个柱面上的不同盘面更好
```

---

提醒：

```
磁盘是可共享设备(分时共享)，是指某段时间内可以有多个用户进行访问。但某一时刻只能有一个作业可以访问
磁盘调度中，对读/写时间影响最大的是寻找时间，寻找过程为机械运动，时间较长，影响较大
硬盘的操作系统引导扇区产生在对硬盘进行高级格式化时。对于高级格式化。操作系统将初始的文件系统数据结构存储到磁盘上
磨损均衡机制的目的是盐城固态硬盘的寿命
当系统中总是持续存在某个磁道的访问请求时，均持续慢速最短存到时间优先、扫描算法和循环扫描算法的访问条件，会一直服务该访问请求，尽管系统中还存在其他磁道的访问请求，但却得不到响应。而先来先服务请求次序进行调度，比较公平
```

## 疑难点

`为了增加设备分配的灵活性、成功率，可以如何改进?`

```
可以从以下两方面对基本的设备分配程序加以改进：
1、增加设备的独立性。进程使用逻辑设备名请求I/O。这样，系统首先从SDT中找出第一个该类设备的DCT。若该设备忙，则又查找第二个该类设备的DCT。仅当所有该类设备都忙时，才将进程挂到该类设备的等待队列上;只要有一个该类设备可用，系统便进一步计算分配该设备的安全性
2、考虑多通路情况。为防止I/O系统的“瓶颈”现象，通常采用多通路的I/O系统结构。此时对控制器和通道的分配同样要经过几次反复，即若设备(控制器)所连接的第一个控制器(通道)忙时，则应查看其所连接的第二个控制器(通道)，仅当所有控制器(通道)都忙时，此次的控制器(通道)分配才算失败，才将进程挂到控制器(通道)的等待队列上。而只要有一个控制器(通道)可用，系统便可将它分配给进程

设备分配过程中，先后分别访问的数据结构为：SDT -> DCT -> COCT -> CHCT
要成功分配一个设备，必须要：1、设备可用；2、控制器可用；3、通道可用
```

`什么是用户缓冲区、内核缓冲区?`

```
“内核”其实是指内核缓冲区，“用户空间”是指用户缓冲区

用户缓冲区是指当用户进程读文件时，通常先申请一块内存数组，称为Buffer，用来存放读取的数据
每次read调用，将读取的数据写入Bufter，之后程序都从Bufter中获取数据，当Buffer使用完后，再进行下一次调用，填充Buffer
可⻅，用户缓冲区的目的是减少系统调用次数，从而降低系统在用户态与核心态之间切换的开销

内核也有自己的缓冲区
当用户进程从磁盘读取数据时，不直接读磁盘，而将内核缓冲区中的数据复制到用户缓冲区中
若内核缓冲区中没有数据，则内核请求从磁盘读取，然后将进程挂起，为其他进程服务，等到数据已读取到内核缓冲区中时，将内核缓冲区中的数据复制到用户进程的缓冲区，才通知进程(当然，I/O模型不同，处理的方式也不同)
当用户进程需要写数据时，数据可能不直接写入磁盘，而将数据写入内核缓冲区，时机适当时(如内核缓冲区的数据积累到一定量后)，内核才将内核缓冲区的数据写入磁盘
可⻅，内核缓冲区是为了在操作系统级别提高磁盘I/O效率，优化磁盘写操作
```

